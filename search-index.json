{
  "articles": [
    {
      "id": "blog-1",
      "title": "Code-first content modeling",
      "slug": "code-first-content-modeling",
      "description": "Explore the advantages of code-first schemas and how Scalar brings structure and flexibility to your stack.",
      "date": "2025-04-11",
      "tags": [
        "Product"
      ],
      "content": "Introduction In the rapidly evolving landscape of content management, the code-first approach has emerged as a powerful paradigm for defining and managing content structures. Unlike traditional UI-based schema editors, code-first modeling puts developers in their comfort zone - working directly with code to define content models. What is Code-First Content Modeling? Code-first content modeling is an approach where content schemas are defined in code rather than through graphical user interfaces....",
      "searchableText": "code-first content modeling explore the advantages of code-first schemas and how scalar brings structure and flexibility to your stack. product introduction in the rapidly evolving landscape of content management, the code-first approach has emerged as a powerful paradigm for defining and managing content structures. unlike traditional ui-based schema editors, code-first modeling puts developers in their comfort zone - working directly with code to define content models. what is code-first content modeling? code-first content modeling is an approach where content schemas are defined in code rather than through graphical user interfaces. this approach offers several advantages: - version control integration - your content models live alongside your application code - type safety - strong typing ensures consistency across your content - developer workflow - use familiar tools and processes for schema changes - reduced context switching - stay in your code editor rather than jumping between interfaces how scalar implements the code-first approach scalar's approach to code-first content modeling emphasizes: 1. type definitions as schema typescript type author = { name: string; image: media; bio: richtext; }; type blogpost = { title: string; slug: string; publishdate: date; author: reference; content: richtext; tags: string; }; 2. automatic api generation from your type definitions, scalar automatically generates: - graphql api endpoints - rest api endpoints - admin ui forms - validation logic 3. schema evolution as your application evolves, your content models can evolve with it: - add new fields without breaking existing content - migrate data between schema versions - deploy schema changes alongside code changes !code-first content modeling illustration showing type definitions and schema generation/images/blog/blog-1.webp benefits for different teams for developers - work in familiar environments - maintain consistency through type safety - test schema changes with standard tools - generate documentation automatically for content teams - structured content enforces quality standards - predictable content models enable automation - powerful querying capabilities - reduced dependency on development for content structure changes getting started with code-first modeling to start implementing code-first content modeling with scalar: 1. define your content types in typescript 2. import the scalar sdk 3. register your models 4. auto-generate your content api conclusion code-first content modeling represents the natural evolution of content management for development teams. by bringing content modeling into the developer workflow, scalar enables more robust, type-safe, and maintainable content structures that can evolve alongside your application.",
      "url": "/writing/code-first-content-modeling"
    },
    {
      "id": "blog-10",
      "title": "Designing a CMS developers actually want to use",
      "slug": "designing-a-cms-developers-actually-want-to-use",
      "description": "A deep dive into our design philosophy at Scalar - from intuitive APIs to a clean UI that feels like part of your stack.",
      "date": "2025-03-07",
      "tags": [
        "Community"
      ],
      "content": "Designing a CMS developers actually want to use !Scalar CMS interface showing a clean design focused on developer experience/images/blog/blog-10.webp A deep dive into our design philosophy at Scalar - from intuitive APIs to a clean UI that feels like part of your stack. Why most CMS interfaces miss the mark We've all been there. You're building a website or application and need a content management system. You evaluate the options, pick one that seems promising, and then the frustration begins:...",
      "searchableText": "designing a cms developers actually want to use a deep dive into our design philosophy at scalar - from intuitive apis to a clean ui that feels like part of your stack. community designing a cms developers actually want to use !scalar cms interface showing a clean design focused on developer experience/images/blog/blog-10.webp a deep dive into our design philosophy at scalar - from intuitive apis to a clean ui that feels like part of your stack. why most cms interfaces miss the mark we've all been there. you're building a website or application and need a content management system. you evaluate the options, pick one that seems promising, and then the frustration begins: - overly complex admin interfaces that editors struggle to navigate - developer experiences that feel like they're from another era - apis that require extensive documentation to understand - integration patterns that fight against your preferred stack - extension systems that are either too limiting or too complex after years of experiencing these frustrations firsthand, we started to wonder: why isn't there a cms that developers actually want to use? this question became the foundation of scalar's design philosophy. developer experience as the north star when we started designing scalar, we established a clear set of principles that would guide our decisions: 1. code-first, visual-optional developers should be able to define content models in code using familiar patterns. visual tools should enhance, not replace, the code experience. typescript // this is how content modeling should feel const author = definetype{ name: 'author', fields: { name: fields.text{ required: true }, bio: fields.richtext, avatar: fields.image{ aspectratio: 1 }, sociallinks: fields.object{ twitter: fields.url, github: fields.url, website: fields.url, }, }, }; 2. your stack, your rules a cms should adapt to your development workflow, not the other way around. scalar is designed to: - work with any frontend framework - support multiple data storage backends - integrate with your existing auth systems - deploy anywhere serverless, containers, vms - version control content alongside code if desired 3. minimal api surface apis should be intuitive enough that you rarely need to check documentation. we obsess over naming, consistency, and predictability. typescript // our apis aim for this level of clarity const posts = await scalar .query'post' .where{ category: 'engineering' } .orderby{ publishdate: 'desc' } .limit10 .include'author', 'relatedposts' .exec; 4. progressive disclosure simple tasks should be simple. complex tasks should be possible. we use progressive disclosure to maintain this balance: - core apis cover 80% of use cases with minimal complexity - extension points reveal power when needed - advanced features don't clutter the basic experience 5. performance by default performance shouldn't be an afterthought or a premium feature. scalar is built for speed from the ground up: - optimized query execution - efficient caching at multiple levels - assets optimized automatically - server and client performance monitoring understanding developer pain points to create a better cms, we needed to deeply understand what frustrates developers about existing solutions. we conducted extensive research, including: - interviews with 100+ developers across different experience levels - analysis of github issues in popular cms repositories - surveys of developer satisfaction with existing cms tools - user testing of early scalar prototypes several key pain points emerged consistently: content modeling limitations many cms platforms either impose rigid structures or offer too little guidance, leading to suboptimal content models. our solution: - flexible type system with sensible defaults - clear patterns for common modeling needs - rich relationship types with referential integrity - schema validation with helpful error messages api inconsistency developers described the cognitive load of working with inconsistent, poorly designed apis as a major pain point. our solution: - consistent api patterns across all interfaces - predictable naming conventions - type-safe client libraries - clear documentation with plenty of examples deployment complexity setting up and maintaining cms infrastructure shouldn't be a project in itself. our solution: - single-command deployment options - infrastructure as code templates - clear separation of concerns - containerized architecture poor editor experiences developers often have to apologize to content teams for the clunky interfaces they're forced to use. our solution: - clean, minimalist ui design - context-aware editing experiences - customizable workflows - performance optimizations for editor tasks balancing developer and editor needs one of the most difficult challenges in cms design is balancing the needs of developers and content editors. too often, platforms prioritize one at the expense of the other. at scalar, we believe this is a false dichotomy. by understanding the true needs of both groups, we can design experiences that work well for everyone. content modeling that serves both audiences scalar's content modeling approach separates structure developer concern from presentation editor concern: typescript // structure defined by developers const productmodel = definetype{ name: 'product', fields: { name: fields.text{ required: true }, price: fields.number{ required: true, validation: { min: 0 }, }, description: fields.richtext, // ...other fields }, }; // presentation configured separately configureeditingexperience{ type: 'product', groups: { name: 'basic info', fields: 'name', 'price', 'category', }, { name: 'details', fields: 'description', 'specifications', 'images', }, { name: 'seo & marketing', fields: 'seotitle', 'seodescription', 'promotext', }, , }; this separation allows: - developers to focus on data integrity and structure - editors to work in a well-organized interface - both sides to collaborate on optimal workflows schema-driven ui scalar automatically generates editing interfaces from your content models, but gives you control where it matters: - field types determine appropriate input components - validation rules create inline validation - field metadata configures options and behaviors - custom field types for specialized needs real-world examples let's look at how our design philosophy translates to real-world developer experiences: case study: blog migration a development team was migrating from a legacy cms to scalar. their experience highlighted several positive outcomes: 1. content modeling clarity \"defining our content models in typescript made the structure explicit in a way our previous cms never did. we uncovered and fixed several data inconsistencies during the migration.\" 2. migration ease \"the migration cli helped us map our old content to the new models, and the validation tools caught issues early.\" 3. frontend integration \"our react components connect directly to scalar's hooks, which reduced the amount of data fetching code we needed to write by around 70%.\" 4. editor satisfaction \"our content team reported that the new editing experience was significantly faster and more intuitive.\" case study: e-commerce product catalog an e-commerce developer shared their experience implementing a product catalog: 1. flexible content modeling \"we needed to support products with drastically different attribute sets. scalar's union types and conditional fields made this straightforward.\" 2. performance at scale \"with over 50,000 products, query performance was a concern. scalar's automatic indexing and query optimization kept things fast without manual tuning.\" 3. custom field types \"creating custom field types for product-specific attributes like size charts and color swatches took less than a day.\" 4. integration with existing systems \"the webhook system made it easy to keep our inventory management system in sync with the cms.\" the road ahead while we've made progress on creating a cms developers actually want to use, our work is far from complete. our roadmap is guided by ongoing developer feedback: near-term improvements - enhanced typescript inference for even better type safety - more granular permissions and role definitions - expanded integrations with development tools - performance improvements for extremely large datasets longer-term vision - ai-assisted content modeling and optimization - enhanced collaboration tools for development teams - more powerful visual customization options - community plugin marketplace conclusion designing a cms that developers actually want to use requires a deep understanding of developer workflows, pain points, and mental models. at scalar, we've made this understanding the foundation of our design philosophy. by prioritizing code-first workflows, consistent apis, flexible integration patterns, and performance, we're building a cms that feels like a natural extension of your development stack rather than a separate system to fight against. we believe that when developers enjoy working with a cms, it leads to better content models, more efficient workflows, and ultimately better experiences for content creators and end users alike. if you're a developer who's experienced the frustrations of traditional cms platforms, we'd love to hear your perspective. what makes a cms enjoyable or painful to work with? share your thoughts in the comments below or join our discord community to continue the conversation.",
      "url": "/writing/designing-a-cms-developers-actually-want-to-use"
    },
    {
      "id": "blog-11",
      "title": "Serverless Deployment for Scalar Applications",
      "slug": "serverless-deployment-for-scalar-applications",
      "description": "Learn how to deploy your Scalar CMS to serverless environments for better scaling, cost efficiency, and simplified management.",
      "date": "2025-03-03",
      "tags": [
        "Guides"
      ],
      "content": "Serverless Deployment for Scalar Applications Learn how to deploy your Scalar CMS to serverless environments for better scaling, cost efficiency, and simplified management. Why Serverless Makes Sense for Content Management The serverless paradigm has transformed how we build and deploy applications. For content management systems like Scalar, serverless architectures offer particularly compelling benefits: - Cost efficiency: Pay only for the resources you actually use - Auto-scaling: Handle traf...",
      "searchableText": "serverless deployment for scalar applications learn how to deploy your scalar cms to serverless environments for better scaling, cost efficiency, and simplified management. guides serverless deployment for scalar applications learn how to deploy your scalar cms to serverless environments for better scaling, cost efficiency, and simplified management. why serverless makes sense for content management the serverless paradigm has transformed how we build and deploy applications. for content management systems like scalar, serverless architectures offer particularly compelling benefits: - cost efficiency: pay only for the resources you actually use - auto-scaling: handle traffic spikes without manual intervention - reduced maintenance: no server management or patching - global distribution: deploy close to your users worldwide - high availability: built-in redundancy and fault tolerance in this guide, we'll walk through deploying a scalar application to popular serverless platforms, examining the specific configuration needed for optimal performance. preparing your scalar application for serverless before deploying to a serverless environment, ensure your scalar application follows these best practices: 1. stateless operation serverless functions should be stateless, with any state stored in external services: typescript // good: using external state management import { createclient } from '@scalar/client'; export const handler = async event => { const client = createclient{ projectid: process.env.scalarprojectid, // state is managed in the external service }; // process request... }; 2. environment configuration store all configuration in environment variables: bash .env.production example scalardatabaseurl=postgresql://user:password@host:port/database scalarstorageprovider=s3 scalarstoragebucket=my-content-bucket scalarapikey=skprodxxxxxxxxxxxx 3. optimized cold starts minimize dependencies and leverage connection pooling to reduce cold start times: typescript // database connection with connection pooling import { pool } from 'pg'; // create the pool once, outside the handler const pool = new pool{ connectionstring: process.env.scalardatabaseurl, max: 1, // limit connections in serverless environments }; export const handler = async event => { // reuse the pool connection const client = await pool.connect; try { // process request... } finally { client.release; } }; 4. asset handling configure asset storage to use cloud-native solutions: typescript // scalar.config.ts export default defineconfig{ storage: { provider: 'cloud', options: { // use environment variables for configuration provider: process.env.scalarstorageprovider, bucket: process.env.scalarstoragebucket, region: process.env.scalarstorageregion, }, }, }; deploying to aws lambda aws lambda is one of the most popular serverless platforms. here's how to deploy scalar: setting up infrastructure we recommend using aws cdk or cloudformation to define your infrastructure as code: typescript // example aws cdk stack import as cdk from 'aws-cdk-lib'; import as lambda from 'aws-cdk-lib/aws-lambda'; import as apigateway from 'aws-cdk-lib/aws-apigateway'; export class scalarserverlessstack extends cdk.stack { constructorscope: cdk.construct, id: string, props?: cdk.stackprops { superscope, id, props; // create lambda function for scalar api const scalarfunction = new lambda.functionthis, 'scalarapifunction', { runtime: lambda.runtime.nodejs18x, handler: 'dist/serverless.handler', code: lambda.code.fromassetpath.joindirname, '../', memorysize: 1024, timeout: cdk.duration.seconds30, environment: { scalardatabaseurl: process.env.scalardatabaseurl!, scalarstorageprovider: 's3', scalarstoragebucket: scalarbucket.bucketname, // other environment variables... }, }; // create api gateway const api = new apigateway.restapithis, 'scalarapi', { deployoptions: { stagename: 'prod', }, }; // set up proxy integration const scalarintegration = new apigateway.lambdaintegrationscalarfunction; api.root.addproxy{ defaultintegration: scalarintegration, }; } } optimizing for lambda to improve performance on lambda: 1. increase memory allocation: this also increases cpu allocation, improving performance 2. enable provisioned concurrency: eliminates cold starts for critical endpoints 3. configure proper timeouts: set api gateway and lambda timeouts appropriately 4. use rds proxy: if using rds, connect through rds proxy to manage database connections deploying to vercel vercel provides a streamlined deployment experience that works well with scalar: project configuration create a vercel.json configuration file: json { \"version\": 2, \"builds\": { \"src\": \"api/serverless.js\", \"use\": \"@vercel/node\" } , \"routes\": { \"src\": \"/api/.\", \"dest\": \"api/serverless.js\" }, { \"src\": \"/.\", \"dest\": \"/api/serverless.js\" } } database configuration for optimal performance on vercel: 1. use edge-compatible databases: like neon, planetscale, or supabase 2. configure connection pooling: to handle concurrent serverless invocations 3. set proper connection limits: to avoid exhausting connection pools typescript // api/serverless.js import { createserveradapter } from '@scalar/adapter-vercel'; import { createapp } from '../src/app'; const app = createapp; const adapter = createserveradapterapp, { poolconnections: true, maxpoolconnections: 10, }; export default adapter; deploying to cloudflare workers cloudflare workers provides a global, low-latency serverless platform ideal for content-heavy applications: scalar configuration create a wrangler.toml file: toml name = \"scalar-cms\" type = \"javascript\" accountid = \"your-account-id\" workersdev = true compatibilitydate = \"2023-01-01\" build command = \"npm run build:worker\" build.upload format = \"service-worker\" env.production route = \"cms.yourdomain.com/\" edge-optimized adapter use scalar's cloudflare adapter for optimal performance: typescript // worker.js import { createserveradapter } from '@scalar/adapter-cloudflare'; import { createapp } from './app'; export default { async fetchrequest, env, ctx { const app = createapp{ database: { type: 'cloudflare-d1', binding: env.scalardb, }, storage: { type: 'cloudflare-r2', binding: env.scalarassets, }, }; const adapter = createserveradapterapp; return adapter.fetchrequest, env, ctx; }, }; cloudflare-native storage for optimal performance, use cloudflare d1 and r2: typescript // migrations using scalar's d1 adapter export default definescalarconfig{ database: { adapter: 'd1', options: { binding: 'scalardb', }, }, storage: { adapter: 'r2', options: { binding: 'scalarassets', publicurl: 'https://assets.yourdomain.com', }, }, }; performance optimization tips regardless of your serverless platform, these optimization tips apply: 1. database connection management database connections are precious in serverless environments: - use connection pooling with appropriate limits - keep connections alive between invocations when possible - consider serverless-friendly databases like aurora serverless 2. caching strategy implement multi-level caching: - cdn caching: for public content - edge caching: for authenticated but non-personalized content - application caching: for frequently accessed data - database query caching: for expensive computations typescript // example caching configuration export default definescalarconfig{ caching: { cdn: { enabled: true, maxage: 3600, // 1 hour }, edge: { enabled: true, maxage: 60, // 1 minute }, application: { enabled: true, ttl: 30, // 30 seconds }, }, }; 3. asset optimization optimize asset handling: - use signed urls for asset uploads - implement on-demand image transformations - enable http/2 for parallel asset loading 4. graphql optimization if using scalar's graphql api: - enable persisted queries for production - implement query complexity analysis - use field-level permissions to restrict data access typescript // graphql optimization configuration export default definescalarconfig{ graphql: { persistedqueries: true, complexitylimit: 1000, depthlimit: 7, introspection: process.env.nodeenv !== 'production', }, }; monitoring and debugging properly monitoring your serverless scalar deployment is crucial: key metrics to track - invocation count: track api usage patterns - execution duration: identify performance bottlenecks - error rate: detect issues quickly - cold start frequency: measure user experience impact - database connection usage: prevent connection exhaustion logging best practices structure your logs for serverless environments: typescript // structured logging example import { createlogger } from '@scalar/logger'; const logger = createlogger{ level: process.env.loglevel || 'info', format: 'json', context: { service: 'scalar-cms', environment: process.env.nodeenv, }, }; // usage logger.info'processing request', { requestid: context.awsrequestid, path: event.path, method: event.httpmethod, }; cost considerations serverless deployments can be very cost-effective, but require attention to these factors: - execution time: optimize code to reduce execution time - memory allocation: balance between cost and performance - database connections: use serverless-compatible databases - data transfer: implement proper caching to reduce data movement - storage costs: optimize asset storage and delivery conclusion deploying scalar to serverless environments provides numerous benefits, from cost optimization to simplified management. by following the platform-specific guidelines and general best practices outlined in this guide, you can ensure your scalar cms performs optimally in production. for more detailed deployment instructions, including platform-specific tutorials, check our deployment documentationhttps://docs.scalar.com/deployment. if you have specific questions or need assistance, join our discord communityhttps://discord.gg/scalar where our team and community members can help you troubleshoot your serverless deployment.",
      "url": "/writing/serverless-deployment-for-scalar-applications"
    },
    {
      "id": "blog-12",
      "title": "Implementing Multilingual Content with Scalar",
      "slug": "implementing-multilingual-content-with-scalar",
      "description": "A comprehensive guide to building truly global websites with Scalar's localization features and best practices.",
      "date": "2025-02-28",
      "tags": [
        "Guides"
      ],
      "content": "Implementing Multilingual Content with Scalar !A world map with connecting lines between different language nodes showing Scalar's multilingual capabilities/images/blog/blog-12.webp A comprehensive guide to building truly global websites with Scalar's localization features and best practices. The Challenge of Global Content Building a truly global digital presence isn't just about translating words—it's about crafting experiences that feel native to each locale. This includes: - Language transla...",
      "searchableText": "implementing multilingual content with scalar a comprehensive guide to building truly global websites with scalar's localization features and best practices. guides implementing multilingual content with scalar !a world map with connecting lines between different language nodes showing scalar's multilingual capabilities/images/blog/blog-12.webp a comprehensive guide to building truly global websites with scalar's localization features and best practices. the challenge of global content building a truly global digital presence isn't just about translating words—it's about crafting experiences that feel native to each locale. this includes: - language translation including rtl languages - cultural adaptation of imagery and examples - region-specific content and features - localized dates, currencies, and measurements - market-specific regulatory compliance many content management systems treat localization as an afterthought, making multilingual implementations complex and fragile. scalar, however, was designed with global content in mind from day one. scalar's approach to localization scalar implements localization following these core principles: 1. locale as a first-class concept: locales aren't bolted on—they're a fundamental part of the content model 2. default locale with overrides: start with a default locale and override only what changes 3. granular localization: localize at the field level, not just the entity level 4. translation workflows: built-in tools for managing translation processes 5. developer ergonomics: simple apis that make implementation straightforward let's explore how these principles translate into practice. setting up your localization strategy configuring supported locales start by defining which locales your application will support: typescript // scalar.config.ts export default defineconfig{ localization: { defaultlocale: 'en-us', supportedlocales: { code: 'en-us', name: 'english us', direction: 'ltr', }, { code: 'fr-fr', name: 'français', direction: 'ltr', }, { code: 'ar-ae', name: 'العربية', direction: 'rtl', }, // add more locales as needed , }, }; locale fallback chains for incomplete translations, scalar provides fallback chains: typescript // scalar.config.ts export default defineconfig{ localization: { // ... other config fallbacks: { 'fr-ca': 'fr-fr', 'en-us', 'es-mx': 'es-es', 'en-us', 'pt-br': 'pt-pt', 'en-us', }, }, }; this means if content isn't available in canadian french fr-ca, scalar will try european french fr-fr, then fall back to us english. content modeling for localization field-level localization in your content models, specify which fields should be localized: typescript // content-models.ts export const product = definetype{ name: 'product', fields: { // localized fields name: fields.text{ localized: true, required: true, }, description: fields.richtext{ localized: true, }, marketingcopy: fields.richtext{ localized: true, }, // non-localized fields shared across all locales sku: fields.text{ localized: false, required: true, }, price: fields.number{ localized: false, required: true, }, images: fields.array{ of: fields.image, localized: false, }, }, }; handling locale-specific content sometimes, certain content should only exist in specific locales. scalar handles this with conditional fields: typescript export const product = definetype{ // ... other fields fields: { // ... other fields // eu-specific regulatory information eucompliance: fields .object{ cemarking: fields.boolean, euenergylabel: fields.image, wastedisposalinfo: fields.text, } .when{ condition: , { locale } => 'de-de', 'fr-fr', 'it-it', 'es-es'.includeslocale, otherwise: fields.hidden, }, // us-specific regulatory information uscompliance: fields .object{ fccid: fields.text, californiaproposition65: fields.boolean, } .when{ condition: , { locale } => locale === 'en-us', otherwise: fields.hidden, }, }, }; creating and managing localized content the content creator experience scalar's admin interface provides a seamless localization experience: 1. locale switcher: quickly toggle between locales 2. visual differentiation: clear highlighting of untranslated content 3. side-by-side editing: compare translations while editing 4. batch translation: apply translations to multiple items simultaneously translation workflows for teams managing translations at scale, scalar includes workflow tools: typescript // configure translation workflows export default defineconfig{ localization: { // ... other configs workflows: { enabled: true, requiredapprovals: 1, notificationrecipients: 'translations@example.com', }, }, }; this enables a structured workflow where: 1. content is created in the primary locale 2. translation tasks are assigned to team members or external vendors 3. translations are submitted for review 4. approved translations are published translation services integration for automated translations, scalar integrates with popular services: typescript export default defineconfig{ localization: { // ... other configs translationservices: { provider: 'deepl', apikey: process.env.deeplapikey, defaultquality: 'standard', allowedfieldtypes: 'text', 'richtext', }, }, }; while machine translation is never perfect, it can provide a useful starting point for human refinement. building the frontend experience fetching localized content when fetching content, specify the desired locale: rest api typescript // fetch in a specific locale const response = await fetch'/api/products?locale=fr-fr'; const products = await response.json; // or with the scalar client import { createclient } from '@scalar/client'; const client = createclient{ projectid: 'your-project-id', }; const products = await client.getcollection'products'.getmany{ locale: 'fr-fr', // other query parameters... }; graphql api graphql query getproducts$locale: string! { productslocale: $locale { id name description price } } typescript const { data } = await client.querygetproducts, { variables: { locale: 'fr-fr' }, }; dynamic locale switching for applications that allow users to switch languages on the client side: tsx import { uselocale } from '@scalar/react-hooks'; function localeswitcher { const { locale, setlocale, supportedlocales } = uselocale; return setlocalee.target.value}> {supportedlocales.maploc => {loc.name} } ; } this will automatically refetch content in the new locale. handling direction changes for rtl language support, ensure your ui adapts appropriately: tsx import { uselocale } from '@scalar/react-hooks'; function layout{ children } { const { direction } = uselocale; return {children} ; } combine this with css logical properties for optimal support: css .container { padding-inline-start: 1rem; padding-inline-end: 2rem; margin-inline-start: auto; margin-inline-end: auto; text-align: start; } url strategies for multilingual sites scalar supports all common url patterns for multilingual sites: 1. subdirectory approach example: example.com/fr/products typescript // next.js example with scalar export async function getstaticpaths { const locales = 'en', 'fr', 'de', 'es'; const slugs = await getproductslugs; const paths = locales.flatmaplocale => slugs.mapslug => { params: { slug }, locale, }, ; return { paths, fallback: 'blocking' }; } export async function getstaticprops{ params, locale } { const product = await getproductparams.slug, locale; return { props: { product } }; } 2. subdomain approach example: fr.example.com/products this requires dns configuration and server routing, but scalar's api works the same way—just pass the locale parameter based on the subdomain. 3. country-specific domains example: example.fr vs example.de similar to the subdomain approach, but with separate domains for each locale. best practices for multilingual content 1. start with content strategy before implementing, define your localization strategy: - which markets are priorities? - will all content be translated, or just key pages? - how will you handle market-specific content? - who will manage translations? - what is your quality assurance process? 2. design with localization in mind - allow space for text expansion german and finnish, for example, often require more space than english - use culture-neutral imagery where possible - implement flexible layouts that work for both ltr and rtl - consider differences in date formats, number formatting, etc. 3. optimize your translation process - provide context for translators - use translation memory to maintain consistency - create a glossary of brand terms - set up automated qa checks 4. implement proper seo - use hreflang tags to indicate language relations - ensure proper metadata in each language - create locale-specific sitemaps typescript // example hreflang implementation export function productpage{ product, alternatelocales } { return {product.title} {alternatelocales.mapalt => } {/ page content /} ; } 5. monitor and improve - track user engagement across locales - identify content that performs differently by region - continuously refine your translation quality - gather feedback from regional users case study: global e-commerce site let's look at how one scalar customer implemented a multilingual e-commerce site supporting 12 languages and 18 locales: challenge they needed to localize: - product information - marketing content - regional pricing and availability - legal documentation - customer support resources solution 1. content modeling: - core product data stored in a single source of truth - localized fields for marketing copy, product names, and descriptions - regional variants for pricing, availability, and shipping 2. workflow: - primary content created in english - automated machine translation for initial drafts - regional teams review and refine translations - legal team approves regulated content 3. technical implementation: - subdirectory url strategy example.com/fr-fr/products - server-side rendering with locale detection - cdn configuration for region-specific edge caching - separate search indexes for each locale results - 40% increase in conversion rates in non-english markets - 65% faster time-to-publish for new products globally - 30% reduction in translation costs conclusion building truly global digital experiences is challenging, but scalar's built-in localization features make it significantly more manageable. by treating localization as a core concern rather than an afterthought, scalar enables teams to create authentic experiences for users worldwide. whether you're localizing a small site into a handful of languages or managing a complex global enterprise, the principles and practices outlined in this guide will help you implement a robust, scalable localization strategy. for more detailed documentation and examples, visit our localization guidehttps://docs.scalar.dev/guides/localization or join our community discordhttps://discord.gg/scalar to discuss your specific implementation.",
      "url": "/writing/implementing-multilingual-content-with-scalar"
    },
    {
      "id": "blog-13",
      "title": "Optimizing Content Performance with Scalar",
      "slug": "optimizing-content-performance-with-scalar",
      "description": "Learn how to leverage Scalar's performance features to deliver lightning-fast content experiences to your users.",
      "date": "2025-02-25",
      "tags": [
        "Guides"
      ],
      "content": "Optimizing Content Performance with Scalar Learn how to leverage Scalar's performance features to deliver lightning-fast content experiences to your users. Why Content Performance Matters In today's digital landscape, user expectations for performance continue to rise. Research consistently shows that: - 53% of users abandon sites that take longer than 3 seconds to load - Each 100ms of latency can reduce conversion rates by up to 1% - Poor performance disproportionately affects users in emerging...",
      "searchableText": "optimizing content performance with scalar learn how to leverage scalar's performance features to deliver lightning-fast content experiences to your users. guides optimizing content performance with scalar learn how to leverage scalar's performance features to deliver lightning-fast content experiences to your users. why content performance matters in today's digital landscape, user expectations for performance continue to rise. research consistently shows that: - 53% of users abandon sites that take longer than 3 seconds to load - each 100ms of latency can reduce conversion rates by up to 1% - poor performance disproportionately affects users in emerging markets - search engines factor load times into ranking algorithms for content-heavy sites and applications, performance optimization begins with how content is structured, stored, and delivered. scalar was built with performance as a core principle, providing tools that make it easy to deliver fast experiences without sacrificing content richness. content delivery architecture before diving into specific optimizations, let's understand scalar's content delivery architecture: ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ │ │ │ │ │ │ │ content api │◄────►│ cdn cache │◄────►│ edge cache │ │ │ │ │ │ │ └───────────────┘ └───────────────┘ └───────────────┘ ▲ ▲ ▲ │ │ │ ▼ ▼ ▼ ┌───────────────┐ ┌───────────────┐ ┌───────────────┐ │ │ │ │ │ │ │ database/cache│ │ client cache │ │ browser cache │ │ │ │ │ │ │ └───────────────┘ └───────────────┘ └───────────────┘ this multi-layered approach provides numerous optimization opportunities. let's explore them: 1. content modeling for performance how you structure your content has a significant impact on performance. follow these best practices: normalize your data model properly normalized content models prevent duplication and improve query efficiency: typescript // instead of duplicating author information in each post const blogpost = definetype{ name: 'blogpost', fields: { title: fields.text{ required: true }, // use a reference instead of embedding author data author: fields.reference{ to: 'author', required: true, }, // other fields... }, }; const author = definetype{ name: 'author', fields: { name: fields.text{ required: true }, bio: fields.richtext, avatar: fields.image, }, }; use field selection wisely not all fields are needed in all contexts. design your queries to fetch only what's needed: typescript // fetch just what's needed for a list view const postsummaries = await scalar .query'blogpost' .select'title', 'publishdate', 'slug' .orderby{ publishdate: 'desc' } .limit10 .exec; // fetch everything for a detail view const fullpost = await scalar .query'blogpost' .where{ slug: 'performance-optimization' } .include'author', 'categories', 'relatedposts' .first; intelligent pagination for large collections, implement pagination to limit payload size: typescript // cursor-based pagination for optimal performance const { items, nextcursor } = await scalar .query'product' .where{ category: 'electronics' } .orderby{ popularity: 'desc' } .paginate{ cursor, limit: 20 }; 2. asset optimization content performance isn't just about data—media assets often account for the bulk of page weight. image processing scalar provides powerful image optimization capabilities: typescript // in your content model const product = definetype{ name: 'product', fields: { // configure image processing defaults image: fields.image{ variants: { thumbnail: { width: 200, height: 200 }, medium: { width: 600, height: 600 }, large: { width: 1200, height: 1200 }, }, defaultformat: 'webp', transformations: { quality: 85, smartcrop: true, }, }, }, }; when retrieving images, you can request specific variants or apply transformations on the fly: tsx // in your react component function productcard{ product } { return {/ responsive images with srcset /} ; } lazy loading media implement lazy loading for below-the-fold content: tsx // using scalar's react sdk for lazy-loaded images import { image } from '@scalar/react-components'; function productgallery{ products } { return {products.mapproduct => } ; } 3. caching strategies proper caching dramatically improves content performance. scalar provides several caching mechanisms: cdn configuration configure cdn caching in your scalar project settings: typescript // scalar.config.ts export default defineconfig{ delivery: { cdn: { enabled: true, cachepolicies: { pattern: '/api/content/', maxage: 3600, // 1 hour smaxage: 86400, // 1 day stalewhilerevalidate: true, }, { pattern: '/api/assets/', maxage: 604800, // 7 days immutable: true, }, , }, }, }; runtime cache control adjust cache behavior at query time: typescript // highly dynamic content - no caching const livescores = await scalar .query'gamescore' .where{ status: 'live' } .cachecontrol{ maxage: 0 } .exec; // semi-static content - short cache const todaysposts = await scalar .query'blogpost' .where{ publishdate: { $gte: today } } .orderby{ publishdate: 'desc' } .cachecontrol{ maxage: 300 } // 5 minutes .exec; // archival content - long cache const archivecontent = await scalar .query'blogpost' .where{ publishdate: { $lt: lastyear } } .cachecontrol{ maxage: 604800 } // 7 days .exec; automatic cache invalidation scalar automatically invalidates caches when content changes, but you can also configure custom invalidation rules: typescript export default defineconfig{ caching: { invalidation: { rules: // when a product changes, invalidate collection pages { contenttype: 'product', invalidate: '/api/collections/', }, // when homepage content changes, invalidate the homepage { contenttype: 'homepage', invalidate: '/api/content/homepage', '/', }, , }, }, }; 4. edge computing for the ultimate in performance, scalar supports edge computing capabilities: edge-optimized api deploy scalar's api to edge locations worldwide: typescript // scalar.config.ts export default defineconfig{ deployment: { type: 'edge', regions: 'auto', // deploy to all edge regions providers: { // configure your preferred edge provider cloudflare: { enabled: true, }, }, }, }; edge middleware implement custom logic at the edge: typescript // middleware.ts import { createedgemiddleware } from '@scalar/edge'; export default createedgemiddleware{ async processrequest, context { // geo-based content customization const country = request.headers.get'cf-ipcountry'; if country { context.geo = { country }; } // a/b testing at the edge const testgroup = math.random { // update ui with new comments updatecommentsuicomments; }; // later, when component unmounts unsubscribe; optimized delta updates when subscribing to large content objects, scalar only transmits changes: typescript // configure delta updates for specific content types export default defineconfig{ realtime: { deltaupdates: { enabled: true, contenttypes: 'dashboarddata', 'analytics', 'userprofile', }, }, }; 6. advanced query optimization for complex data models, query optimization becomes crucial: indexing strategy define indexes to support your common query patterns: typescript // scalar.config.ts export default defineconfig{ database: { indexes: { contenttype: 'product', fields: { name: 'category', direction: 'asc' }, { name: 'price', direction: 'asc' }, , name: 'productcategoryprice', }, { contenttype: 'blogpost', fields: { name: 'tags', direction: 'asc' }, { name: 'publishdate', direction: 'desc' }, , name: 'blogposttagsdate', }, , }, }; query analysis use scalar's query analysis tools to identify slow queries: bash enable query logging in development scalar dev --query-logging=true or in production configuration export default defineconfig{ database: { monitoring: { querylogging: { enabled: true, slowquerythreshold: 500 // log queries taking > 500ms } } } }; materialized views for complex aggregations or reporting queries, use materialized views: typescript // scalar.config.ts export default defineconfig{ database: { materializedviews: { name: 'popularproducts', query: select p.id, p.name, p.slug, counto.id as ordercount from product p join orderitem oi on p.id = oi.productid join order o on oi.orderid = o.id where o.createdat > now - interval '30 days' group by p.id, p.name, p.slug order by ordercount desc limit 100 , refreshinterval: '1 hour', }, , }, }; 7. frontend optimization while much of performance optimization happens on the backend, frontend techniques matter too: state management scalar's client libraries include efficient state management: typescript // react example with automatic request deduplication import { usecontent } from '@scalar/react-hooks'; function productlist{ category } { // multiple components can request the same data // without duplicate network requests const { data, loading, error } = usecontent'product', { where: { category }, orderby: { popularity: 'desc' }, limit: 10, }; // render component... } predictive prefetching implement predictive prefetching for common navigation paths: typescript import { prefetchcontent } from '@scalar/client'; function productcard{ product } { const handlemouseenter = => { // prefetch full product details on hover prefetchcontent'product', { where: { id: product.id }, include: 'related', 'reviews', 'variants' }; }; return {/ product card content /} ; } 8. monitoring and optimization continuous monitoring is essential for maintaining performance: real user monitoring implement rum to understand actual user experience: typescript // scalar.config.ts export default defineconfig{ monitoring: { rum: { enabled: true, samplerate: 0.1, // monitor 10% of requests excludepaths: '/admin/', '/api/health', }, }, }; performance dashboard scalar provides a built-in performance dashboard showing: - api response times by endpoint - cache hit rates - asset delivery performance - database query performance - error rates access this at /admin/performance in your scalar admin interface. automated optimization suggestions scalar analyzes your usage patterns and provides automated suggestions: typescript // run the performance advisor scalar performance:analyze // sample output: // ✅ query optimization: add index on 'blogpost.author' to improve query performance // ✅ cache optimization: consider increasing cache ttl for '/api/products' to reduce database load // ✅ asset optimization: 3 images exceed recommended size limits case study: e-commerce performance optimization let's look at how one customer optimized their scalar-powered e-commerce site: initial challenges - product listing pages loading in 3.5s average - product detail pages loading in 2.8s - cart updates taking 750ms - mobile conversion rate 40% lower than desktop applied optimizations 1. content model redesign - normalized product variants - created dedicated models for pricing and inventory - implemented intelligent content references 2. image pipeline - implemented responsive image variants - adopted webp with jpeg fallback - set up image quality tiers by importance 3. caching strategy - product listings: 1 hour cdn cache - product details: 4 hour cache with revalidation - personalized content: edge-computed with 5-minute cache 4. regional deployment - deployed scalar api to 6 edge regions - implemented regional database replicas - configured intelligent request routing results - product listing pages: 950ms average load 73% improvement - product detail pages: 780ms average load 72% improvement - cart updates: 120ms 84% improvement - mobile conversion rate improved by 28% - 65% reduction in origin server load conclusion performance optimization is an ongoing process, not a one-time effort. scalar provides the tools and architecture to build high-performance content experiences, but the most significant gains come from thoughtful implementation and continuous refinement. by applying the strategies outlined in this guide, you can ensure your content delivers the speed and responsiveness users expect, regardless of scale or complexity. for more detailed performance guidance, explore our performance documentationhttps://docs.scalar.dev/guides/performance or reach out to our support teamhttps://scalar.dev/support for personalized optimization recommendations.",
      "url": "/writing/optimizing-content-performance-with-scalar"
    },
    {
      "id": "blog-14",
      "title": "Content Lifecycle Management with Scalar",
      "slug": "content-lifecycle-management-with-scalar",
      "description": "How to implement comprehensive governance from creation to archival using Scalar's workflow features.",
      "date": "2025-02-22",
      "tags": [
        "Guides"
      ],
      "content": "Content Lifecycle Management with Scalar How to implement comprehensive governance from creation to archival using Scalar's workflow features. Beyond Basic Content Management Modern organizations face increasingly complex content challenges: - Growing content volumes across multiple channels - Diverse content teams with specialized roles - Compliance and governance requirements - Need for content reuse and repurposing - Long-term content maintenance and archival Basic create-publish-update opera...",
      "searchableText": "content lifecycle management with scalar how to implement comprehensive governance from creation to archival using scalar's workflow features. guides content lifecycle management with scalar how to implement comprehensive governance from creation to archival using scalar's workflow features. beyond basic content management modern organizations face increasingly complex content challenges: - growing content volumes across multiple channels - diverse content teams with specialized roles - compliance and governance requirements - need for content reuse and repurposing - long-term content maintenance and archival basic create-publish-update operations are no longer sufficient. organizations need comprehensive content lifecycle management—a systematic approach to governing content from inception to retirement. scalar provides a robust framework for implementing end-to-end content lifecycle management. this post explores how to leverage these capabilities to bring structure and efficiency to your content operations. the content lifecycle framework a well-designed content lifecycle typically includes these phases: 1. planning - strategy, ideation, and scheduling 2. creation - authoring, design, and assembly 3. review - editing, approval, and compliance checks 4. publishing - release, distribution, and promotion 5. maintenance - updates, optimization, and monitoring 6. archival - retirement, preservation, and pruning let's examine how to implement each phase using scalar. phase 1: content planning effective content begins with proper planning. scalar supports this phase through: content calendar scalar's calendar interface provides a visual overview of planned content: typescript // define scheduling metadata in your content model const blogpost = definetype{ name: 'blogpost', fields: { // standard content fields... // planning fields plannedpublishdate: fields.date{ required: true, description: 'target date for publishing', }, author: fields.reference{ to: 'author', required: true, }, status: fields.select{ options: { label: 'planned', value: 'planned' }, { label: 'in progress', value: 'in-progress' }, { label: 'in review', value: 'in-review' }, { label: 'ready', value: 'ready' }, { label: 'published', value: 'published' }, { label: 'updated', value: 'updated' }, { label: 'archived', value: 'archived' }, , defaultvalue: 'planned', }, priority: fields.select{ options: { label: 'low', value: 'low' }, { label: 'medium', value: 'medium' }, { label: 'high', value: 'high' }, , defaultvalue: 'medium', }, }, }; content strategy metadata enhance your content with strategic context: typescript const contentpiece = definetype{ // ... other fields // strategy fields contentgoal: fields.select{ options: { label: 'acquisition', value: 'acquisition' }, { label: 'conversion', value: 'conversion' }, { label: 'retention', value: 'retention' }, { label: 'support', value: 'support' }, { label: 'brand building', value: 'brand' }, , }, targetpersona: fields.reference{ to: 'persona', many: true, }, targetkeywords: fields.array{ of: fields.text, }, contentbrief: fields.document{ description: 'strategic brief for this content piece', }, }; assignment and workflow initialization set up automated processes to streamline planning: typescript // define a workflow rule export default defineconfig{ workflows: { rules: { name: 'assign new content', on: { event: 'create', contenttype: 'blogpost', }, actions: { type: 'notification', to: 'content-team@example.com', subject: 'new content piece assigned: {{title}}', message: a new content piece has been planned: title: {{title}} due date: {{plannedpublishdate}} author: {{author.name}} priority: {{priority}} , }, { type: 'update', field: 'status', value: 'planned', }, , }, , }, }; phase 2: content creation the creation phase is where ideas transform into structured content. scalar provides several features to support efficient creation: structured content templates create templates for common content types: typescript // define a template export const blogposttemplate = { title: 'new blog post', description: 'enter a compelling description here...', content: { type: 'doc', content: { type: 'heading', attrs: { level: 1 }, content: { type: 'text', text: 'main headline' }, }, { type: 'paragraph', content: { type: 'text', text: 'start with a compelling introduction...', }, , }, { type: 'heading', attrs: { level: 2 }, content: { type: 'text', text: 'first subheading' }, }, { type: 'paragraph', content: { type: 'text', text: 'explain your first point...', }, , }, // additional structure... , }, status: 'in-progress', }; // register the template export default defineconfig{ templates: { blogpost: { name: 'standard blog post', template: blogposttemplate, }, { name: 'how-to guide', template: howtotemplate, }, // other templates... , }, }; collaborative authoring enable real-time collaboration between team members: typescript // configure collaboration features export default defineconfig{ collaboration: { enabled: true, trackchanges: true, presence: true, comments: { enabled: true, notifications: true, }, }, }; progress tracking monitor content creation progress: typescript const blogpost = definetype{ // ... other fields completionstatus: fields.object{ outline: fields.boolean{ defaultvalue: false }, firstdraft: fields.boolean{ defaultvalue: false }, mediaassets: fields.boolean{ defaultvalue: false }, technicalreview: fields.boolean{ defaultvalue: false }, finaledit: fields.boolean{ defaultvalue: false }, }, completionpercentage: fields.computed{ resolve: doc => { const statuses = doc.completionstatus; const completed = object.valuesstatuses.filterboolean.length; const total = object.valuesstatuses.length; return completed / total 100; }, }, }; phase 3: review and approval the review phase ensures content meets quality standards before publishing. scalar's workflow engine excels at orchestrating complex reviews: multi-stage approval workflows define comprehensive approval processes: typescript // scalar.config.ts export default defineconfig{ workflows: { approvals: { types: { blogpost: { stages: { name: 'editorial review', description: 'check for grammar, style, and structure', assignees: 'editor-group', requiredapprovals: 1, }, { name: 'technical review', description: 'verify technical accuracy', assignees: 'technical-reviewers', requiredapprovals: 1, conditional: content => content.category === 'technical' || content.tags.includes'technical', }, { name: 'legal review', assignees: 'legal-team', requiredapprovals: 1, conditional: content => content.requireslegalreview || content.tags.includes'compliance', }, { name: 'final approval', assignees: 'content-director', requiredapprovals: 1, }, , }, }, }, }, }; review ui scalar provides a dedicated interface for reviews with: - side-by-side comparison with previous versions - inline commenting and threaded discussions - suggested edits functionality - approval/rejection with required feedback - audit trail of all review activities quality checks implement automated quality validations: typescript // configure quality checks export default defineconfig{ validation: { rules: { name: 'minimum content length', contenttype: 'blogpost', check: doc => { const wordcount = doc.content.textcontent.split/\\s+/.length; return { valid: wordcount >= 800, message: article contains ${wordcount} words, minimum is 800, }; }, }, { name: 'seo title length', contenttype: 'blogpost', check: doc => { return { valid: doc.title.length { const imagecount = doc.content.queryselectorall'image'.length; return { valid: imagecount >= 2, message: article contains ${imagecount} images, minimum is 2, }; }, }, , }, }; phase 4: publishing the publishing phase makes content available to its intended audience. scalar provides robust tools for controlled, scheduled release: scheduled publishing set up content to publish automatically at the optimal time: typescript // configure scheduled publishing export default defineconfig{ publishing: { scheduling: { enabled: true, timezone: 'america/newyork', schedulingfield: 'publishdate', }, }, }; // in your content model const blogpost = definetype{ // ... other fields publishdate: fields.datetime{ description: 'when this content should go live', }, expirydate: fields.datetime{ description: 'when this content should be unpublished optional', }, }; publishing workflows automate actions that should occur upon publishing: typescript // define publishing workflow export default defineconfig{ workflows: { rules: { name: 'content publishing actions', on: { event: 'publish', contenttype: 'blogpost', }, actions: { // send notifications type: 'notification', to: 'marketing@example.com', 'social@example.com', subject: 'new blog post published: {{title}}', message: a new blog post has been published: title: {{title}} url: {{url}} author: {{author.name}} category: {{category}} please promote this content through appropriate channels. , }, { // update status type: 'update', field: 'status', value: 'published', }, { // trigger webhook to external systems type: 'webhook', url: 'https://api.example.com/social-scheduler', method: 'post', body: { contenttype: 'blogpost', title: '{{title}}', excerpt: '{{description}}', url: '{{url}}', image: '{{coverimage.url}}', }, }, , }, , }, }; multi-channel distribution configure content for distribution across multiple channels: typescript const contentpiece = definetype{ // ... other fields distribution: fields.object{ website: fields.boolean{ defaultvalue: true }, emailnewsletter: fields.boolean{ defaultvalue: false }, socialmedia: fields.object{ twitter: fields.boolean{ defaultvalue: false }, linkedin: fields.boolean{ defaultvalue: false }, facebook: fields.boolean{ defaultvalue: false }, instagram: fields.boolean{ defaultvalue: false }, }, syndication: fields.array{ of: fields.select{ options: { label: 'medium', value: 'medium' }, { label: 'dev.to', value: 'devto' }, { label: 'partner network', value: 'partners' }, , }, }, }, channelspecificcontent: fields.object{ socialheadline: fields.text{ description: 'alternative headline for social media optional', }, emailsubject: fields.text{ description: 'subject line when used in emails', }, twittertext: fields.text{ description: 'twitter-specific copy optional', validation: { maxlength: 280 }, }, }, }; phase 5: content maintenance after publishing, content requires ongoing maintenance. scalar's features support efficient content upkeep: content freshness tracking monitor content age and relevance: typescript const blogpost = definetype{ // ... other fields lastrevieweddate: fields.date, reviewfrequency: fields.select{ options: { label: 'monthly', value: 'monthly' }, { label: 'quarterly', value: 'quarterly' }, { label: 'annually', value: 'annually' }, { label: 'as needed', value: 'as-needed' }, , defaultvalue: 'quarterly', }, freshnessscore: fields.computed{ resolve: doc => { if !doc.lastrevieweddate return 0; const today = new date; const reviewed = new datedoc.lastrevieweddate; const dayssincereview = math.floor today - reviewed / 1000 60 60 24, ; // calculate score based on review frequency switch doc.reviewfrequency { case 'monthly': return math.max0, 100 - dayssincereview / 30 100; case 'quarterly': return math.max0, 100 - dayssincereview / 90 100; case 'annually': return math.max0, 100 - dayssincereview / 365 100; default: return 50; // middle score for \"as needed\" } }, }, }; update workflows automate maintenance processes: typescript // configure content review reminders export default defineconfig{ workflows: { rules: { name: 'content review reminder', schedule: '0 9 1', // every monday at 9am query: { contenttype: 'blogpost', where: { lastrevieweddate: { $lt: '{{now-90d}}', // content not reviewed in 90 days }, status: 'published', }, }, actions: { type: 'notification', to: '{{content.author.email}}', 'content-manager@example.com', subject: 'content review needed: {{content.title}}', message: the following content is due for review: title: {{content.title}} last reviewed: {{content.lastrevieweddate}} url: {{content.url}} please review this content for accuracy and relevance. , }, { type: 'update', field: 'reviewstatus', value: 'due', }, , }, , }, }; performance monitoring track content effectiveness over time: typescript const blogpost = definetype{ // ... other fields analytics: fields.object{ views: fields.number{ defaultvalue: 0 }, uniquevisitors: fields.number{ defaultvalue: 0 }, averagetimeonpage: fields.number{ defaultvalue: 0 }, conversionrate: fields.number{ defaultvalue: 0 }, lastupdated: fields.datetime, }, performancetrend: fields.select{ options: { label: 'increasing', value: 'increasing' }, { label: 'stable', value: 'stable' }, { label: 'decreasing', value: 'decreasing' }, { label: 'not enough data', value: 'insufficient' }, , defaultvalue: 'insufficient', }, }; phase 6: archival and content pruning the final phase of the content lifecycle involves strategic retirement of outdated content. scalar provides tools for responsible content pruning: archival workflow set up processes for content retirement: typescript // configure archival workflow export default defineconfig{ workflows: { rules: { name: 'content archival process', on: { event: 'update', contenttype: 'blogpost', condition: before, after => before.status !== 'archived' && after.status === 'archived', }, actions: { // create redirect type: 'createredirect', source: '{{slug}}', destination: '/blog', ispermanent: true, }, { // notify team type: 'notification', to: 'content-team@example.com', subject: 'content archived: {{title}}', message: the following content has been archived: title: {{title}} url: {{url}} archived by: {{user.email}} reason: {{archivalreason}} a 301 redirect has been created to the blog index. , }, { // remove from search index type: 'webhook', url: 'https://api.example.com/search-index/remove', method: 'post', body: { id: '{{id}}', url: '{{url}}', }, }, , }, , }, }; archival metadata add fields to track content retirement: typescript const contentpiece = definetype{ // ... other fields archivalmetadata: fields .object{ archivaldate: fields.date, archivalreason: fields.select{ options: { label: 'outdated information', value: 'outdated' }, { label: 'low performance', value: 'low-performance' }, { label: 'redundant content', value: 'redundant' }, { label: 'product discontinued', value: 'discontinued' }, { label: 'legal/compliance', value: 'legal' }, { label: 'other', value: 'other' }, , }, archivalnotes: fields.text, replacementcontentid: fields.reference{ to: 'blogpost', 'page', 'document', }, } .when{ condition: doc => doc.status === 'archived', required: true, }, }; content preservation ensure content is properly preserved for future reference: typescript // configure content preservation settings export default defineconfig{ archival: { preservation: { enabled: true, strategy: 'snapshot', formats: 'html', 'json', 'pdf', storage: { provider: 's3', bucket: 'content-archive', pathprefix: 'archives/', }, metadata: { includeversionhistory: true, includeanalytics: true, }, }, }, }; implementing a complete lifecycle system to bring all these elements together into a cohesive system: 1. define clear statuses create a comprehensive set of statuses that reflect your lifecycle: typescript const contentstatuses = { label: 'draft', value: 'draft' }, { label: 'in review', value: 'in-review' }, { label: 'approved', value: 'approved' }, { label: 'scheduled', value: 'scheduled' }, { label: 'published', value: 'published' }, { label: 'update needed', value: 'update-needed' }, { label: 'updating', value: 'updating' }, { label: 'archived', value: 'archived' }, ; 2. create dashboard views configure role-specific dashboards: typescript // configure dashboards export default defineconfig{ dashboards: { editors: { widgets: { type: 'content-list', title: 'content needing review', query: { contenttype: 'blogpost', where: { status: 'in-review' }, orderby: { updatedat: 'asc' }, }, }, { type: 'calendar', title: 'publishing calendar', query: { contenttype: 'blogpost', where: { status: { $in: 'approved', 'scheduled' }, }, }, datefield: 'publishdate', }, , }, contentmanagers: { widgets: { type: 'metrics', title: 'content health', metrics: { name: 'fresh content', query: { contenttype: 'blogpost', where: { freshnessscore: { $gte: 70 } }, }, calculation: 'count', }, { name: 'stale content', query: { contenttype: 'blogpost', where: { freshnessscore: { $lt: 30 } }, }, calculation: 'count', }, , }, { type: 'chart', title: 'content by status', charttype: 'pie', query: { contenttype: 'blogpost', groupby: 'status', }, }, , }, }, }; 3. set up role-based permissions configure permissions aligned with your workflow: typescript // configure role-based permissions export default defineconfig{ roles: { 'content-creator': { permissions: { contenttype: '', actions: 'create', 'read', 'update', conditions: { status: { $nin: 'approved', 'published', 'archived' }, }, }, , }, editor: { permissions: { contenttype: '', actions: 'create', 'read', 'update', 'approve', conditions: { status: { $nin: 'archived' }, }, }, , }, 'content-manager': { permissions: { contenttype: '', actions: 'create', 'read', 'update', 'approve', 'publish', 'archive', , }, , }, }, }; 4. connect external systems integrate with other tools in your content ecosystem: typescript // configure integrations export default defineconfig{ integrations: { analytics: { type: 'google-analytics', propertyid: 'ua-xxxxxxxxx-x', syncschedule: '0 0 ', // daily at midnight }, marketing: { type: 'hubspot', apikey: process.env.hubspotapikey, mappings: { blogpost: { contenttype: 'blogpost', fields: { title: 'name', publishdate: 'publishdate', 'author.name': 'author', url: 'url', }, }, }, }, translation: { type: 'smartling', apikey: process.env.smartlingapikey, projectid: process.env.smartlingprojectid, }, }, }; case study: enterprise content lifecycle implementation a large financial services company implemented comprehensive content lifecycle management with scalar. here's how they structured their approach: challenge with over 5,000 content pieces across multiple product lines, they struggled with: - inconsistent review processes - outdated regulatory information - poor visibility into content performance - inefficient update workflows - content duplication and overlap solution they implemented a scalar-powered content hub with: 1. centralized content repository - unified content types across the organization - standardized metadata and tagging - integrated taxonomy management 2. compliance-focused workflow - legal and compliance review stages - automated expiration for time-sensitive content - complete audit trails for regulatory purposes 3. performance-driven maintenance - automated analytics collection - quarterly review cycles based on content type - structured archival process with proper redirects 4. integration ecosystem - connected to customer support knowledge base - integrated with marketing automation - linked to learning management system results after implementation, they achieved: - 65% reduction in compliance incidents - 40% improvement in content update efficiency - 30% reduction in duplicate content - 85% of content now reviewed within appropriate timeframes - complete defensible audit trail for regulators conclusion effective content lifecycle management isn't just about tools—it's about establishing clear processes that govern how content moves through your organization. scalar provides the technical framework to implement these processes, but success depends on aligning technology with your team's workflows and organizational needs. by implementing comprehensive lifecycle management, you can ensure your content remains accurate, relevant, and effective throughout its useful life—from initial planning through eventual archival. to learn more about content lifecycle management with scalar, explore our detailed documentationhttps://docs.scalar.dev/guides/content-lifecycle or join our community forumhttps://community.scalar.dev to discuss best practices with other content operations professionals.",
      "url": "/writing/content-lifecycle-management-with-scalar"
    },
    {
      "id": "blog-15",
      "title": "Building Custom Field Types in Scalar",
      "slug": "building-custom-field-types-in-scalar",
      "description": "Extend Scalar's content modeling capabilities with custom fields tailored to your specific business needs.",
      "date": "2025-02-19",
      "tags": [
        "Guides"
      ],
      "content": "Building Custom Field Types in Scalar Extend Scalar's content modeling capabilities with custom fields tailored to your specific business needs. Beyond Standard Fields Scalar comes with a robust set of built-in field types that cover most content modeling needs: - Text-based fields: text, multiline, richText, markdown, etc. - Numeric fields: number, integer, decimal, etc. - Selection fields: select, multiSelect, boolean, etc. - Media fields: image, file, video, audio, etc. - Relationship fields:...",
      "searchableText": "building custom field types in scalar extend scalar's content modeling capabilities with custom fields tailored to your specific business needs. guides building custom field types in scalar extend scalar's content modeling capabilities with custom fields tailored to your specific business needs. beyond standard fields scalar comes with a robust set of built-in field types that cover most content modeling needs: - text-based fields: text, multiline, richtext, markdown, etc. - numeric fields: number, integer, decimal, etc. - selection fields: select, multiselect, boolean, etc. - media fields: image, file, video, audio, etc. - relationship fields: reference, relation, etc. - structural fields: object, array, etc. however, there are always domain-specific requirements that call for specialized content structures. this is where custom field types come in. custom fields allow you to extend scalar's type system with your own field implementations that perfectly match your business domain. in this guide, we'll explore how to build, implement, and deploy custom fields in scalar. use cases for custom fields before diving into implementation, let's consider some real-world scenarios where custom fields can add significant value: e-commerce product specifications standard fields might be insufficient for complex product data like: - size charts with unit conversion - color swatches with hex values and named colors - nutrition facts for food products - technical specifications with standardized values location and geospatial data projects dealing with location data might need: - address fields with formatting and validation - map coordinates with visual selection - region selectors with hierarchical data - distance calculators specialized content types domain-specific content often requires custom structures: - code snippets with syntax highlighting - mathematical equations with rendering - chemical formulas - medical data with standardized codes interactive elements custom fields can power interactive content: - quizzes and assessments - interactive calculators - configurable forms - embedded widgets let's build some practical examples to demonstrate how custom fields work in scalar. building your first custom field we'll start with a relatively simple but practical example: a color picker field that stores and validates color values. 1. setting up the development environment first, create a new package for your custom field: bash mkdir scalar-color-field cd scalar-color-field npm init -y npm install --save-dev @scalar/field-types react typescript create a typescript configuration: json // tsconfig.json { \"compileroptions\": { \"target\": \"es2018\", \"module\": \"esnext\", \"moduleresolution\": \"node\", \"declaration\": true, \"outdir\": \"./dist\", \"strict\": true, \"jsx\": \"react\", \"esmoduleinterop\": true, \"skiplibcheck\": true }, \"include\": \"src\", \"exclude\": \"nodemodules\", \"dist\" } 2. defining the field schema create the field type definition: typescript // src/schema.ts import { definefield, fieldvalidators } from '@scalar/field-types'; // define the color field schema export interface colorfieldschema { defaultvalue?: string; allowedformats?: 'hex' | 'rgb' | 'rgba' | 'hsl'; presets?: { name: string; value: string; }; } // define color field specific validators export interface colorfieldvalidators extends fieldvalidators { hexonly?: boolean; includealpha?: boolean; } // define the field type export const colorfield = definefield{ // type name used in content models name: 'color', // default configuration defaultconfig: { allowedformats: 'hex', 'rgb', 'rgba', presets: , }, // field schema validations validateconfig: config => { const errors = ; // validate default value matches allowed formats if config.defaultvalue && !isvalidcolorconfig.defaultvalue, config.allowedformats { errors.push default value \"${config.defaultvalue}\" must be a valid color in one of the allowed formats., ; } // return validation results return { valid: errors.length === 0, errors }; }, // value validation logic validatevalue: value, config, validators => { if value === undefined || value === null { return { valid: true }; } const errors = ; // check if it's a valid color if !isvalidcolorvalue, config.allowedformats { errors.pushvalue must be a valid color in one of the allowed formats.; } // check hex-only validation if specified if validators?.hexonly && !value.startswith'' { errors.push'value must be in hexadecimal format.'; } // check alpha validation if specified if validators?.includealpha === false && value.startswith'rgba' || value.includes',' && value.split','.length > 3 { errors.push'alpha values are not allowed.'; } return { valid: errors.length === 0, errors }; }, }; // helper function to validate colors function isvalidcolor value: string, allowedformats?: 'hex' | 'rgb' | 'rgba' | 'hsl', : boolean { // basic validation for various color formats const patterns = { hex: /^a-fa-f0-9{3}|a-fa-f0-9{6}|a-fa-f0-9{8}$/, rgb: /^rgb\\\\s\\d+\\s,\\s\\d+\\s,\\s\\d+\\s\\$/, rgba: /^rgba\\\\s\\d+\\s,\\s\\d+\\s,\\s\\d+\\s,\\s0|0\\.\\d+|1|1\\.0+\\s\\$/, hsl: /^hsl\\\\s\\d+\\s,\\s\\d+%\\s,\\s\\d+%\\s\\$/, }; // if no formats are specified, allow all const formats = allowedformats || 'hex', 'rgb', 'rgba', 'hsl'; // check if the value matches any of the allowed formats return formats.someformat => patternsformat.testvalue; } 3. creating the input component next, create the react component that renders the color picker: tsx // src/colorinput.tsx import react, { usestate, useeffect } from 'react'; import { fieldinputprops } from '@scalar/field-types'; import { colorfieldschema } from './schema'; export const colorinput: react.fc > = { value, onchange, config, disabled, error } => { const colorvalue, setcolorvalue = usestate value || config.defaultvalue || '000000', ; // update the parent when local value changes useeffect => { if value !== colorvalue { onchangecolorvalue; } }, colorvalue; // update local state when the value prop changes useeffect => { if value && value !== colorvalue { setcolorvaluevalue; } }, value; // handle input changes const handleinputchange = e: react.changeevent => { setcolorvaluee.target.value; }; // handle preset selection const handlepresetclick = presetvalue: string => { setcolorvaluepresetvalue; }; return {config.presets && config.presets.length > 0 && {config.presets.mappreset, index => handlepresetclickpreset.value} disabled={disabled} /> } } {error && {error}} ; }; 4. defining the preview component create a component for displaying the color in read-only contexts: tsx // src/colorpreview.tsx import react from 'react'; import { fieldpreviewprops } from '@scalar/field-types'; import { colorfieldschema } from './schema'; export const colorpreview: react.fc > = { value, config } => { if !value { return no color selected; } return {value} ; }; 5. creating the main export tie everything together in your main file: tsx // src/index.ts import { registerfieldtype } from '@scalar/field-types'; import { colorfield } from './schema'; import { colorinput } from './colorinput'; import { colorpreview } from './colorpreview'; // register the field type registerfieldtype{ type: colorfield, input: colorinput, preview: colorpreview, }; // export all components and types export { colorfield, colorinput, colorpreview }; export from './schema'; 6. building and publishing create a build script in your package.json: json { \"name\": \"scalar-color-field\", \"version\": \"1.0.0\", \"main\": \"dist/index.js\", \"types\": \"dist/index.d.ts\", \"scripts\": { \"build\": \"tsc\", \"prepare\": \"npm run build\" }, \"peerdependencies\": { \"@scalar/field-types\": \"^1.0.0\", \"react\": \"^17.0.0 || ^18.0.0\" }, \"devdependencies\": { \"@scalar/field-types\": \"^1.0.0\", \"@types/react\": \"^18.0.0\", \"react\": \"^18.0.0\", \"typescript\": \"^4.5.5\" } } run the build and publish your package: bash npm run build npm publish using custom fields in scalar now that we've created our custom color field, let's see how to use it in a scalar project. installing the custom field in your scalar project: bash npm install scalar-color-field registering the field in your scalar configuration: typescript // scalar.config.ts import { defineconfig } from '@scalar/config'; import 'scalar-color-field'; // this registers the field type export default defineconfig{ // your scalar configuration }; using the field in a content model typescript // content-types.ts import { definetype, fields } from 'scalar'; import { colorfield } from 'scalar-color-field'; const product = definetype{ name: 'product', fields: { name: fields.text{ required: true }, // use the custom color field primarycolor: colorfield{ allowedformats: 'hex', 'rgb', presets: { name: 'brand blue', value: '0066cc' }, { name: 'brand red', value: 'cc0000' }, { name: 'brand green', value: '00cc66' }, , validation: { hexonly: true, }, }, // other fields... }, }; building more complex custom fields now that we understand the basics, let's explore a more complex custom field: an address field with formatting and validation. address field schema typescript // src/schema.ts import { definefield, fieldvalidators } from '@scalar/field-types'; // define the address data structure export interface addressdata { street1: string; street2?: string; city: string; state: string; zipcode: string; country: string; coordinates?: { latitude: number; longitude: number; }; } // define the address field schema export interface addressfieldschema { defaultvalue?: partial; availablecountries?: string; requirecoordinates?: boolean; formatstring?: string; } // define address field specific validators export interface addressfieldvalidators extends fieldvalidators { validatezipcode?: boolean; requirestreet2?: boolean; } // define the field type export const addressfield = definefield{ name: 'address', defaultconfig: { availablecountries: 'us', 'ca', 'gb', requirecoordinates: false, formatstring: '{{street1}}{{if street2}}, {{street2}}{{/if}}, {{city}}, {{state}} {{zipcode}}, {{country}}', }, // custom serialization to json tojson: value => { if !value return null; return json.stringifyvalue; }, // custom parsing from json fromjson: json => { if !json return null; try { return json.parsejson; } catch e { return null; } }, // format the address for display format: value, config => { if !value return ''; // use the format string to format the address let formatted = config.formatstring || ''; // replace simple tokens object.entriesvalue.foreachkey, val => { if typeof val === 'string' { formatted = formatted.replacenew regexp{{${key}}}, 'g', val; } }; // handle conditionals const conditionalregex = /{{if \\w+}}.?{{\\/if}}/g; formatted = formatted.replaceconditionalregex, match, field, content => { return valuefield ? content : ''; }; return formatted; }, // validate the field configuration validateconfig: config => { const errors = ; // validate format string if config.formatstring && !config.formatstring.includes'{{street1}}' { errors.push'format string must include {{street1}} token'; } return { valid: errors.length === 0, errors }; }, // validate the field value validatevalue: value, config, validators => { if !value { return { valid: true }; } const errors = ; // check required fields 'street1', 'city', 'state', 'zipcode', 'country'.foreachfield => { if !valuefield { errors.push${field} is required; } }; // check if street2 is required if validators?.requirestreet2 && !value.street2 { errors.push'street2 is required'; } // check if coordinates are required if config.requirecoordinates && !value.coordinates { errors.push'coordinates are required'; } // check available countries if value.country && config.availablecountries && !config.availablecountries.includesvalue.country { errors.push country must be one of: ${config.availablecountries.join', '}, ; } // validate zip code format if enabled if validators?.validatezipcode && value.zipcode { // simple zip code validation for us if value.country === 'us' && !/^\\d{5}-\\d{4}?$/.testvalue.zipcode { errors.push'invalid us zip code format'; } // add other country postal code validations as needed } return { valid: errors.length === 0, errors }; }, }; the implementation would follow a similar pattern to our color field, but with more complex input and preview components. this example demonstrates the flexibility of scalar's custom field api to handle complex, structured data types. advanced field features let's explore some advanced features you can implement in your custom fields: 1. remote data integration fields can fetch data from external sources: tsx // productskuinput component const productskuinput: react.fc> = { value, onchange, config, } => { const skudata, setskudata = usestatenull; const loading, setloading = usestatefalse; // fetch product data when sku changes useeffect => { if !value return; setloadingtrue; fetch/api/products/validate-sku?sku=${value} .thenres => res.json .thendata => { setskudatadata; setloadingfalse; } .catch => { setskudatanull; setloadingfalse; }; }, value; return onchangee.target.value} /> {loading && validating sku...} {skudata && ✓ valid sku product: {skudata.name} stock: {skudata.stocklevel} category: {skudata.category} } ; }; 2. custom validation rules implement complex validation logic: typescript // isbn field validator validatevalue: value, config, validators => { if !value return { valid: true }; const errors = ; // remove hyphens and spaces const cleanisbn = value.replace/-\\s/g, ''; // validate isbn-10 if cleanisbn.length === 10 { let sum = 0; for let i = 0; i > = { value, onchange, config } => { const currentvalue = value || { amount: 0, currency: 'usd' }; const handleamountchange = e => { onchange{ ...currentvalue, amount: parsefloate.target.value, }; }; const handlecurrencychange = e => { onchange{ ...currentvalue, currency: e.target.value, }; }; return $ € £ ¥ ; }; 4. rich media fields create fields for specialized media: tsx // 360 degree product view field const productview360input: react.fc> = { value, onchange, config, } => { const images, setimages = usestatevalue || ; const uploadprogress, setuploadprogress = usestate0; const handlefileupload = async files => { setuploadprogress0; const uploadedurls = ; let completed = 0; for const file of files { // upload the file const formdata = new formdata; formdata.append'file', file; const response = await fetch'/api/upload', { method: 'post', body: formdata, onuploadprogress: progressevent => { const progress = completed + progressevent.loaded / progressevent.total / files.length; setuploadprogressprogress 100; }, }; const result = await response.json; uploadedurls.pushresult.url; completed += 1 / files.length; } // sort images by filename to ensure correct order const sortedurls = uploadedurls.sort; setimagessortedurls; onchangesortedurls; setuploadprogress100; }; return handlefileuploade.target.files} /> upload 24-36 images taken at equal intervals around the product {uploadprogress > 0 && uploadprogress } {images.length > 0 && {images.length} images {/ 360 view preview component /} } ; }; sharing and publishing field types to make your custom fields reusable across projects and teams: 1. field type registries create a central registry for your organization's field types: typescript // @your-org/scalar-fields/src/index.ts // import and re-export all custom fields export { colorfield } from './color-field'; export { addressfield } from './address-field'; export { pricefield } from './price-field'; export { skufield } from './sku-field'; // and so on... // register all fields import './color-field'; import './address-field'; import './price-field'; import './sku-field'; // and so on... 2. documentation add comprehensive documentation: typescript // documented field type export const productspecificationfield = definefield{ name: 'productspec', / product specification field for standardized technical specifications. @example typescript const product = definetype{ fields: { technicalspecs: productspecificationfield{ categories: 'dimensions', 'performance', 'connectivity', allowcustomspecs: true } } }; @see documentation at https://your-docs-site.com/fields/product-spec / // field implementation... }; 3. testing add tests to ensure quality: typescript // field type test describe'colorfield', => { it'validates hex colors correctly', => { const field = colorfield{ allowedformats: 'hex', }; const valid = field.validatevalue'ff5733', field.config; expectvalid.valid.tobetrue; const invalid = field.validatevalue'rgb255, 87, 51', field.config; expectinvalid.valid.tobefalse; expectinvalid.errors.tocontain 'value must be a valid color in one of the allowed formats.', ; }; // more tests... }; case study: domain-specific fields here's how one organization leveraged custom fields for their specific domain: healthcare document management system a healthcare provider built custom fields for their clinical documentation system: 1. medication field - autocomplete from medication database - dose calculator with unit conversion - interaction checker - formulary status indicator 2. diagnosis code field - icd-10 code validator - hierarchical code browser - related codes suggestion 3. vitals field - range validation by patient demographics - trend visualization - anomaly highlighting these custom fields significantly improved data quality and clinical workflow efficiency. by building these as reusable field types, they maintained consistency across their suite of healthcare applications. conclusion custom field types allow you to extend scalar's capabilities to perfectly match your business domain. by creating specialized fields, you can: - improve data quality through custom validation - enhance the editing experience with domain-specific inputs - ensure consistent data structures across your content models - reduce implementation complexity for specialized content types whether you're building simple ui enhancements like color pickers or complex domain-specific fields like medical record components, scalar's field type system provides the flexibility to meet your needs. ready to build your own custom fields? check out our field type sdk documentationhttps://docs.scalar.dev/sdk/field-types and join our developer communityhttps://discord.gg/scalar to share your creations with other scalar developers.",
      "url": "/writing/building-custom-field-types-in-scalar"
    },
    {
      "id": "blog-2",
      "title": "How Scalar generates GraphQL APIs instantly",
      "slug": "how-scalar-generates-graphql-apis-instantly",
      "description": "Learn how Scalar turns your content models into ready-to-query GraphQL endpoints - no backend setup required.",
      "date": "2025-04-08",
      "tags": [
        "Product"
      ],
      "content": "How Scalar generates GraphQL APIs instantly Learn how Scalar turns your content models into ready-to-query GraphQL endpoints - no backend setup required. The GraphQL Revolution GraphQL has revolutionized how we build and consume APIs. Unlike REST, GraphQL allows clients to request exactly the data they need, reducing over-fetching and under-fetching problems. However, implementing GraphQL traditionally requires significant backend work - from schema design to resolver implementation. Scalar's Ze...",
      "searchableText": "how scalar generates graphql apis instantly learn how scalar turns your content models into ready-to-query graphql endpoints - no backend setup required. product how scalar generates graphql apis instantly learn how scalar turns your content models into ready-to-query graphql endpoints - no backend setup required. the graphql revolution graphql has revolutionized how we build and consume apis. unlike rest, graphql allows clients to request exactly the data they need, reducing over-fetching and under-fetching problems. however, implementing graphql traditionally requires significant backend work - from schema design to resolver implementation. scalar's zero-config graphql scalar's approach eliminates this complexity through automatic graphql api generation from your content models. here's how it works: 1. from content model to graphql schema when you define a content model in scalar, whether through the ui or code-first approach, scalar automatically: - generates a corresponding graphql schema - creates appropriate types, queries, and mutations - handles relationships between content types - sets up filtering, pagination, and sorting 2. intelligent type mapping scalar maps your content fields to appropriate graphql types: | content field | graphql type | | ------------- | ------------------- | | text | string | | number | float or int | | boolean | boolean | | date | datetime | | rich text | json | | references | custom object types | | media | asset type | 3. automatic resolver generation behind the scenes, scalar generates optimized resolvers that: - efficiently fetch data from the database - handle connections between content types - implement pagination with cursor-based navigation - apply security rules and access control developer experience using scalar's graphql api is straightforward: graphql query { blogposts where: { tags: { contains: \"graphql\" } } orderby: { publishdate: desc } first: 10 { edges { node { title description publishdate author { name image { url } } } } } } performance optimizations scalar's graphql implementation includes several performance optimizations: - dataloader integration - prevents n+1 query problems - query complexity analysis - protects against abusive queries - automatic caching - reduces database load - query batching - consolidates multiple operations beyond basic queries scalar's graphql api supports advanced features: full-text search graphql query { blogpostswhere: { or: { title: { contains: \"graphql\" } }, { content: { contains: \"graphql\" } } } { fields } } localization graphql query { blogpostslocale: \"fr-fr\" { title description } } content previews graphql query { blogpostspreview: true { includes unpublished content } } integration with frontend frameworks scalar's graphql api works seamlessly with popular frontend tooling: - react with apollo client or react query - vue with vue apollo - next.js with built-in data fetching - mobile apps with apollo ios/android conclusion by automatically generating graphql apis from your content models, scalar eliminates a significant development burden. this approach lets teams focus on building features rather than implementing api layers, while still benefiting from graphql's flexibility and performance advantages.",
      "url": "/writing/how-scalar-generates-graphql-apis-instantly"
    },
    {
      "id": "blog-3",
      "title": "Scaling content teams without slowing down",
      "slug": "scaling-content-teams-without-slowing-down",
      "description": "Role-based permissions, draft workflows, and live preview - how Scalar empowers content editors to move fast without breaking things.",
      "date": "2025-04-05",
      "tags": [
        "Product"
      ],
      "content": "Scaling content teams without slowing down Role-based permissions, draft workflows, and live preview - how Scalar empowers content editors to move fast without breaking things. The Growing Pains of Content Teams As organizations grow, content operations face increasing challenges: - More content creators and editors working simultaneously - Complex approval workflows across departments - Higher quality standards and brand consistency requirements - Faster publishing cycles with less room for err...",
      "searchableText": "scaling content teams without slowing down role-based permissions, draft workflows, and live preview - how scalar empowers content editors to move fast without breaking things. product scaling content teams without slowing down role-based permissions, draft workflows, and live preview - how scalar empowers content editors to move fast without breaking things. the growing pains of content teams as organizations grow, content operations face increasing challenges: - more content creators and editors working simultaneously - complex approval workflows across departments - higher quality standards and brand consistency requirements - faster publishing cycles with less room for error - integration with multiple distribution channels traditional content management systems often become bottlenecks during this scaling phase. scalar is designed specifically to solve these challenges. role-based permissions: the right access for everyone granular permission control scalar's role-based permission system allows you to define exactly what each team member can do: - viewer - can see content but not edit - editor - can create and modify content, but not publish - publisher - can approve and publish content - admin - full control over content and settings - custom roles - define specialized roles for your workflow content-type specific permissions permissions can be assigned at the content-type level, so you can: - restrict blog editing to the content team - allow product teams to manage product descriptions - give legal teams review access for compliance-sensitive content - enable marketing to manage promotional materials draft workflows: safe content evolution multi-stage approval process scalar's draft workflows enable clear content progression: 1. draft - initial content creation 2. in review - ready for editorial feedback 3. approved - validated but not yet published 4. published - live content 5. archived - previously published content parallel workstreams with draft workflows, your team can: - work on future content while current content is live - prepare seasonal campaigns in advance - a/b test different content variations - maintain evergreen content alongside timely updates live preview: what you see is what you get real-time visualization content creators can see exactly how their content will appear: - preview across multiple device sizes - see how content renders in different contexts - visualize content with actual design and layout contextual editing live preview provides important context for content decisions: - understand character and word limits visually - see how images and text interact - identify layout issues before publishing - test interactive elements version control: a safety net for your content comprehensive history every content change is tracked with: - who made the change - when it was made - what specifically was changed - comments explaining the change easy rollback if issues arise, content can be quickly restored: - compare any two versions - restore previous versions with one click - selectively roll back specific fields - track changes across publishing stages collaborative tools: working together seamlessly commenting and feedback team members can: - leave feedback on specific content elements - request changes with clear context - mention colleagues to bring them into discussions - resolve comments when addressed notifications and alerts keep everyone in the loop with: - publishing reminders and deadlines - approval requests - mention notifications - content status changes conclusion as content teams scale, their tools must evolve to support more complex workflows without adding friction. scalar's approach to permissions, drafts, previews, and collaboration creates an environment where content teams can scale efficiently - publishing more content, with more contributors, without sacrificing quality or speed.",
      "url": "/writing/scaling-content-teams-without-slowing-down"
    },
    {
      "id": "blog-4",
      "title": "Introducing Scalar Cloud",
      "slug": "introducing-scalar-cloud",
      "description": "We are launching Scalar Cloud - everything you love about Scalar, now hosted with autoscale, team features, and zero setup.",
      "date": "2025-04-01",
      "tags": [
        "Changelog"
      ],
      "content": "Introducing Scalar Cloud We are launching Scalar Cloud - everything you love about Scalar, now hosted with autoscale, team features, and zero setup. A Major Milestone Today marks a significant evolution in Scalar's journey. After more than a year of development and extensive beta testing with select customers, we're thrilled to announce the general availability of Scalar Cloud. Scalar Cloud brings the power of our headless CMS to a fully-managed, cloud-native environment with enhanced security,...",
      "searchableText": "introducing scalar cloud we are launching scalar cloud - everything you love about scalar, now hosted with autoscale, team features, and zero setup. changelog introducing scalar cloud we are launching scalar cloud - everything you love about scalar, now hosted with autoscale, team features, and zero setup. a major milestone today marks a significant evolution in scalar's journey. after more than a year of development and extensive beta testing with select customers, we're thrilled to announce the general availability of scalar cloud. scalar cloud brings the power of our headless cms to a fully-managed, cloud-native environment with enhanced security, reliability, and collaboration features. why scalar cloud? while our open-source version continues to power thousands of websites and applications worldwide, we heard consistent feedback from enterprise customers and growing teams: > \"we love scalar's developer experience and content modeling, but we need more robust scaling, security, and team features without having to manage the infrastructure ourselves.\" scalar cloud is our answer to these needs. key features zero-configuration deployment getting started with scalar cloud takes less than 5 minutes: 1. sign up for a scalar cloud account 2. create a new project 3. import your content models or start fresh 4. invite your team no servers to provision, databases to configure, or scaling parameters to tune. autoscaling infrastructure scalar cloud automatically scales to meet your needs: - handles traffic spikes gracefully - scales down during quiet periods to optimize costs - automatically distributes load across regions - no configuration required enhanced team collaboration scalar cloud adds powerful team features: - organization management - create and manage multiple teams - sso integration - connect with your identity provider google, github, okta - audit logs - track all system and content changes - advanced permissions - fine-grained role definitions global content delivery your content is served from the edge: - global cdn integration - automatic cache invalidation - regional data residency options - low-latency api responses worldwide enterprise-grade security scalar cloud adds enhanced security measures: - soc 2 compliance type ii in progress - gdpr and ccpa compliant data handling - automatic backups with point-in-time recovery - dedicated vp-cs available for enterprise plans pricing options scalar cloud is available in four tiers: starter - $29/month - up to 3 team members - 25gb asset storage - 1m api requests/month - community support professional - $99/month - up to 10 team members - 100gb asset storage - 5m api requests/month - email support business - $299/month - up to 25 team members - 500gb asset storage - 25m api requests/month - priority support & sla enterprise - custom pricing - unlimited team members - custom storage limits - custom request limits - dedicated support & custom sla open source commitment our commitment to open source remains unwavering. scalar cloud is built on the same core as our open source offering, and improvements will continue to flow in both directions. the open source version will always remain free and will continue to receive feature updates and security patches. revenue from scalar cloud will help fund more extensive work on both versions. get started today we're offering a 14-day free trial of scalar cloud with no credit card required. experience the full power of the platform and see how it can transform your content operations. try scalar cloud →https://cloud.scalar.dev we can't wait to see what you build!",
      "url": "/writing/introducing-scalar-cloud"
    },
    {
      "id": "blog-5",
      "title": "REST vs GraphQL",
      "slug": "rest-vs-graphql",
      "description": "A practical look at when to use GraphQL vs REST APIs for headless CMS integrations - and how Scalar supports both.",
      "date": "2025-03-28",
      "tags": [
        "Guides"
      ],
      "content": "REST vs GraphQL A practical look at when to use GraphQL vs REST APIs for headless CMS integrations - and how Scalar supports both. The API Dilemma When building applications that consume content from a headless CMS, one of the first architectural decisions is choosing between REST and GraphQL APIs. Both approaches have passionate advocates, and both have distinct strengths and limitations. Rather than declaring a winner, this guide helps you make an informed choice based on your specific project...",
      "searchableText": "rest vs graphql a practical look at when to use graphql vs rest apis for headless cms integrations - and how scalar supports both. guides rest vs graphql a practical look at when to use graphql vs rest apis for headless cms integrations - and how scalar supports both. the api dilemma when building applications that consume content from a headless cms, one of the first architectural decisions is choosing between rest and graphql apis. both approaches have passionate advocates, and both have distinct strengths and limitations. rather than declaring a winner, this guide helps you make an informed choice based on your specific project needs. at scalar, we support both api paradigms because we understand different projects have different requirements. understanding the basics rest: the established standard rest representational state transfer has been the dominant api pattern for over a decade. it organizes resources into endpoints that follow standard http methods get, post, put, delete: get /api/blog-posts get all blog posts get /api/blog-posts/123 get a specific blog post post /api/blog-posts create a new blog post put /api/blog-posts/123 update a blog post delete /api/blog-posts/123 delete a blog post graphql: the flexible newcomer graphql, developed by facebook and released in 2015, uses a single endpoint where clients specify exactly what data they need: graphql query { blogpostid: \"123\" { title author { name profileimage } comments { text createdat } } } key differences | aspect | rest | graphql | | -------------- | ---------------------------------------------------- | -------------------------------------------------- | | endpoints | multiple endpoints for different resources | single endpoint for all operations | | data fetching | often requires multiple requests to get related data | can fetch complex related data in a single request | | overfetching | common - endpoints return fixed data structures | rare - clients specify exactly what they need | | underfetching | common - may need multiple requests | rare - can request all needed data at once | | caching | simple, built into http | requires custom implementation | | file uploads | native support | requires extensions | | error handling | http status codes | always returns 200 with errors in response | | tooling | vast ecosystem | growing ecosystem | when to choose rest rest may be your better option when: 1. you need simple, resource-oriented operations for basic crud operations on well-defined resources, rest provides a straightforward implementation that most developers already understand. 2. you want to leverage http caching rest's alignment with http methods makes it easy to use standard caching mechanisms, both on the client side and with cdns. 3. your api consumers have bandwidth limitations rest can be more efficient for small, focused requests where you don't need related data. 4. you need straightforward file handling rest handles file uploads natively through multipart requests, while graphql requires additional implementation. when to choose graphql graphql shines when: 1. your frontend needs flexible data requirements different views may need different fields from the same resources. graphql lets clients specify exactly what they need. 2. you want to reduce network requests instead of making multiple api calls to assemble a complex view, graphql can fetch all required data in a single request. 3. your data is highly relational graphql makes it easy to traverse relationships between resources without additional endpoint calls. 4. you need strong typing and introspection graphql's schema system provides built-in documentation and type checking. how scalar supports both approaches scalar gives you the freedom to choose the right api for your needs: rest api features - resource-based endpoints for all content types - standard crud operations - filtering, sorting, and pagination - relationship expansion via query parameters - asset handling and file uploads - comprehensive documentation graphql api features - full schema generation from your content models - nested queries for related content - mutations for content creation and updates - filtering, sorting, and pagination arguments - built-in documentation via introspection - performance optimizations to prevent n+1 queries hybrid approaches many scalar users adopt a hybrid approach: - using graphql for complex, data-heavy frontend views - using rest for simple administrative actions or file uploads - leveraging rest for public-facing cached content - employing graphql for personalized or dynamic content conclusion there's no one-size-fits-all answer to the rest vs graphql question. by supporting both api styles, scalar gives you the flexibility to choose the right approach for each specific use case in your project. whether you prefer the simplicity and familiarity of rest or the flexibility and efficiency of graphql, scalar provides optimized implementations of both paradigms.",
      "url": "/writing/rest-vs-graphql"
    },
    {
      "id": "blog-6",
      "title": "Building a blog with Scalar, Next.js, and Tailwind",
      "slug": "building-a-blog-with-scalar-next-js-and-tailwind",
      "description": "Follow this step-by-step guide to launch a performant, developer-friendly blog using Scalar CMS and your favorite tools.",
      "date": "2025-03-25",
      "tags": [
        "Guides"
      ],
      "content": "Building a blog with Scalar, Next.js, and Tailwind Follow this step-by-step guide to launch a performant, developer-friendly blog using Scalar CMS and your favorite tools. The Perfect Tech Stack for Modern Blogs Blogs remain one of the most effective ways to share knowledge, build authority, and connect with your audience. But today's readers expect fast, responsive, and visually appealing blog experiences. In this tutorial, we'll build a high-performance blog using three powerful technologies:...",
      "searchableText": "building a blog with scalar, next.js, and tailwind follow this step-by-step guide to launch a performant, developer-friendly blog using scalar cms and your favorite tools. guides building a blog with scalar, next.js, and tailwind follow this step-by-step guide to launch a performant, developer-friendly blog using scalar cms and your favorite tools. the perfect tech stack for modern blogs blogs remain one of the most effective ways to share knowledge, build authority, and connect with your audience. but today's readers expect fast, responsive, and visually appealing blog experiences. in this tutorial, we'll build a high-performance blog using three powerful technologies: - scalar for flexible content management - next.js for fast, seo-friendly rendering - tailwind css for beautiful, responsive designs this combination gives you the benefits of a headless cms approach content flexibility, developer experience, performance without sacrificing the ease of use content creators expect. prerequisites before we start, make sure you have: - node.js 18+ installed - a scalar account free tier works fine - basic familiarity with react and next.js - git for version control step 1: setting up your scalar project let's start by configuring our content models in scalar. creating a new project 1. log in to your scalar account 2. create a new project named \"next.js blog\" 3. choose the blank template defining content models we'll create two main content types: author and blogpost. author model typescript // in scalar schema editor type author = { name: string; bio: richtext; avatar: media; sociallinks?: { twitter?: string; github?: string; linkedin?: string; }; }; blog post model typescript // in scalar schema editor type blogpost = { title: string; slug: string; summary: string; content: richtext; coverimage: media; publisheddate: date; featured: boolean; author: reference; tags: string; seo?: { title?: string; description?: string; keywords?: string; }; }; adding sample content before we move to the frontend, let's add: - at least one author - 3-5 blog posts with varied content step 2: creating your next.js project now let's set up our frontend application. bash create a new next.js project npx create-next-app@latest my-scalar-blog --typescript --tailwind --app navigate to your project cd my-scalar-blog install scalar sdk and other dependencies npm install @scalar/api-client date-fns reading-time step 3: connecting to scalar create a new file at lib/scalar.ts: typescript import { createclient } from '@scalar/api-client'; export const scalarclient = createclient{ projectid: process.env.scalarprojectid!, apikey: process.env.scalarapikey!, }; export async function getblogposts{ featured, limit, }: { featured?: boolean; limit?: number; } = {} { const query: any = {}; if featured !== undefined { query.featured = featured; } const posts = await scalarclient.getblogposts{ query, sort: { publisheddate: 'desc' }, limit, include: 'author', }; return posts; } export async function getblogpostbyslugslug: string { const posts = await scalarclient.getblogposts{ query: { slug }, limit: 1, include: 'author', }; return posts0 || null; } create a .env.local file: scalarprojectid=your-project-id scalarapikey=your-api-key step 4: building the blog homepage create app/page.tsx: tsx import link from 'next/link'; import image from 'next/image'; import { getblogposts } from '@/lib/scalar'; export default async function homepage { const posts = await getblogposts{ limit: 10 }; const featuredpost = posts.findpost => post.featured; const regularposts = posts.filterpost => !post.featured; return my blog {featuredpost && featured } {regularposts.mappost => } ; } // add featuredpostcard and postcard components here step 5: creating the blog post page create app/blog/slug/page.tsx: tsx import image from 'next/image'; import { notfound } from 'next/navigation'; import { getblogpostbyslug } from '@/lib/scalar'; import { formatdate } from '@/lib/utils'; export default async function blogpostpage{ params, }: { params: { slug: string }; } { const post = await getblogpostbyslugparams.slug; if !post { notfound; } return {post.title} {post.author.name} {formatdatepost.publisheddate} {/ render your rich text content here /} {post.content} ; } step 6: adding navigation and layout create or modify app/layout.tsx: tsx import './globals.css'; import link from 'next/link'; export default function rootlayout{ children, }: { children: react.reactnode; } { return my blog home about contact {children} © {new date.getfullyear} my blog. all rights reserved. ; } step 7: enhancing your blog to take your blog to the next level, consider these enhancements: adding a rich text renderer install a package to render your rich text content: bash npm install @scalar/rich-text-react use it in your blog post page. implementing tags and categories create tag and category pages to organize your content. adding search functionality implement search using scalar's filtering capabilities. setting up analytics add a web analytics tool to track visitor engagement. deployment the simplest way to deploy your next.js blog is with vercel: bash npm install -g vercel vercel make sure to add your scalar environment variables in the vercel dashboard. conclusion you now have a fully functioning blog powered by scalar, next.js, and tailwind css. this stack gives you: - a clean, type-safe content api - blazing fast page loads with ssr and static generation - beautiful responsive design - great developer experience from here, you can continue customizing your blog with additional features, design tweaks, and content strategy.",
      "url": "/writing/building-a-blog-with-scalar-next-js-and-tailwind"
    },
    {
      "id": "blog-7",
      "title": "From markdown to structured content",
      "slug": "from-markdown-to-structured-content",
      "description": "Why content teams are moving away from flat files and how structured data unlocks collaboration, APIs, and automation.",
      "date": "2025-03-20",
      "tags": [
        "Product"
      ],
      "content": "From markdown to structured content Why content teams are moving away from flat files and how structured data unlocks collaboration, APIs, and automation. The Evolution of Content Management Content management has evolved dramatically over the past decade. From basic text files to sophisticated structured content systems, the way we create, store, and distribute content continues to transform. This evolution reflects changing needs: - Higher content volumes across more channels - More complex re...",
      "searchableText": "from markdown to structured content why content teams are moving away from flat files and how structured data unlocks collaboration, apis, and automation. product from markdown to structured content why content teams are moving away from flat files and how structured data unlocks collaboration, apis, and automation. the evolution of content management content management has evolved dramatically over the past decade. from basic text files to sophisticated structured content systems, the way we create, store, and distribute content continues to transform. this evolution reflects changing needs: - higher content volumes across more channels - more complex relationships between content pieces - growing teams with specialized roles - the rise of programmatic content consumption - requirements for personalization and dynamic delivery markdown files were a major improvement over raw html or proprietary formats, but as organizations scale, flat files show their limitations. the limitations of flat file content markdown and other flat file approaches offer simplicity but present challenges for growing organizations: 1. limited structured data support markdown is excellent for basic content like paragraphs, lists, and simple formatting. however, it struggles with complex data like: - product specifications with multiple attributes - author profiles with social links and expertise areas - event listings with dates, locations, and registration links - media assets with licensing and usage information while frontmatter helps, it's ultimately a workaround for a format not designed for complex data. 2. weak content relationships flat files exist in isolation, making relationships difficult to express and maintain: - cross-references between related content - content reuse across multiple pages - parent-child relationships - many-to-many associations this isolation leads to duplication, inconsistency, and maintenance headaches. 3. challenging collaboration workflows as teams grow, file-based systems become problematic: - concurrent editing conflicts - no built-in review mechanisms - limited accountability tracking - manual publishing processes - difficult permissions management 4. poor api support in an api-driven world, flat files require significant additional infrastructure: - custom parsing and transformation - ad-hoc caching systems - manual api implementation - limited query capabilities the benefits of structured content structured content addresses these limitations by treating content as data with defined schemas, relationships, and workflows. 1. content modeling flexibility structured content systems let you define custom models that precisely match your needs: javascript // a sample content model type author = { name: string; biography: richtext; expertise: string; headshot: image; socialprofiles: { twitter?: string; linkedin?: string; github?: string; }; }; type article = { title: string; subtitle?: string; slug: string; author: reference; publishdate: datetime; category: reference; tags: string; featuredimage: image; content: richtext; relatedarticles: reference; }; this approach ensures consistency while offering complete flexibility. 2. api-first architecture structured content is inherently api-ready: - consistent, well-documented endpoints - rich filtering and query capabilities - built-in versioning - comprehensive crud operations - format transformation json, xml, etc. 3. collaborative workflows modern structured content systems include robust collaboration features: - real-time collaborative editing - role-based access control - approval workflows - comment threads and feedback - publishing scheduling - comprehensive audit trails 4. automation and integration structured content enables powerful automation: - triggered workflows based on content changes - scheduled content operations - integration with marketing automation - analytics and performance tracking - localization workflows making the transition moving from markdown or other flat file systems to structured content requires planning: 1. content audit and modeling - inventory your existing content - identify common patterns and structures - define content types and their relationships - consider future content needs 2. migration strategy - develop a phased approach - create scripts for automated conversion - plan for manual enrichment of complex content - maintain parallel systems during transition 3. team training - document new workflows - provide hands-on training - gather feedback and refine processes - identify and empower system champions conclusion while markdown and flat files have served content teams well, structured content represents the next evolution in content management. by treating content as data with defined schemas, relationships, and workflows, organizations unlock new capabilities around collaboration, automation, and delivery. the transition requires investment, but the returns in efficiency, consistency, and capabilities make it worthwhile for growing content operations. structured content doesn't just solve today's problems—it prepares you for tomorrow's opportunities.",
      "url": "/writing/from-markdown-to-structured-content"
    },
    {
      "id": "blog-8",
      "title": "How we built Scalar's visual model editor",
      "slug": "how-we-built-scalar",
      "description": "Go behind the scenes with our product team on building Scalar's drag-and-drop schema editor - and what's coming next.",
      "date": "2025-03-16",
      "tags": [
        "Product"
      ],
      "content": "How we built Scalar's visual model editor Go behind the scenes with our product team on building Scalar's drag-and-drop schema editor - and what's coming next. The Challenge of Content Modeling When we started building Scalar, we identified a critical pain point in the content management space: content modeling tools were either too technical or too simplistic. Developers wanted precision and control, while content teams needed intuitive interfaces. Both needed to collaborate effectively. We cha...",
      "searchableText": "how we built scalar's visual model editor go behind the scenes with our product team on building scalar's drag-and-drop schema editor - and what's coming next. product how we built scalar's visual model editor go behind the scenes with our product team on building scalar's drag-and-drop schema editor - and what's coming next. the challenge of content modeling when we started building scalar, we identified a critical pain point in the content management space: content modeling tools were either too technical or too simplistic. developers wanted precision and control, while content teams needed intuitive interfaces. both needed to collaborate effectively. we challenged ourselves to build a visual content modeling interface that would: 1. be approachable enough for non-technical users 2. offer the depth and flexibility developers expect 3. support complex content relationships and structures 4. generate production-ready schemas without compromise this post details our journey building scalar's visual model editor, the technical challenges we faced, and what we learned along the way. starting with user research before writing a single line of code, we conducted extensive user research with both developers and content creators. a few key insights emerged: - developers appreciated visual tools but distrusted them if they couldn't see or control the underlying code - content teams often felt excluded from modeling decisions, despite having the best understanding of content needs - both groups valued being able to quickly iterate on content structures - everyone disliked unpleasant surprises when models were deployed to production these insights formed our core design principles: transparency, collaboration, and precision. the technical approach architecture decisions we knew from the start we needed a robust, real-time system with a clear separation of concerns: ┌─────────────────┐ ┌────────────────┐ ┌────────────────┐ │ │ │ │ │ │ │ visual editor │◄────►│ schema store │◄────►│ code layer │ │ │ │ │ │ │ └─────────────────┘ └────────────────┘ └────────────────┘ ▲ ▲ ▲ │ │ │ └────────────────────────┼───────────────────────┘ │ ┌───────▼───────┐ │ │ │ persistence & │ │ sync │ │ │ └───────────────┘ this architecture ensured changes in the visual editor would instantly reflect in the code layer and vice versa. technology stack our technology choices focused on performance and developer experience: - frontend: react with typescript for type safety - state management: a custom redux-inspired store with middleware - schema validation: json schema with custom extensions - real-time synchronization: websockets with conflict resolution - code generation: abstract syntax tree manipulation the canvas interface the heart of our editor is the canvas interface. we needed to balance flexibility with guidance, which led to several key features: 1. drag-and-drop field creation - simple yet powerful 2. visual relationship mapping - connecting content types intuitively 3. nested field structures - supporting complex data hierarchies 4. real-time validation - catching errors before they become problems 5. instant previews - showing how content would look in the editing interface technical challenges building the editor presented several non-trivial challenges: challenge 1: schema synchronization keep the visual representation and code representation in perfect sync proved complex. our solution: typescript // simplified synchronization middleware const synchronizationmiddleware = store => next => action => { const prevstate = store.getstate; const result = nextaction; const nextstate = store.getstate; if action.source === 'visual-editor' { // update code representation const generatedcode = generatecodefromschemanextstate.schema; if generatedcode !== prevstate.coderepresentation { store.dispatch{ type: 'updatecoderepresentation', payload: generatedcode, source: 'synchronization', }; } } else if action.source === 'code-editor' { // update visual representation const parsedschema = parsecodetoschemanextstate.coderepresentation; if !isequivalentparsedschema, prevstate.schema { store.dispatch{ type: 'updateschema', payload: parsedschema, source: 'synchronization', }; } } return result; }; challenge 2: relationship visualization representing complex relationships visually required careful design: typescript // relationship rendering logic simplified function renderrelationshiprelationship, viewportstate { const { source, target, type } = relationship; const sourceposition = getnodepositionsource, viewportstate; const targetposition = getnodepositiontarget, viewportstate; // calculate control points for curved lines const controlpoints = calculatebeziercontrolpoints sourceposition, targetposition, type ; return {/ render relationship labels and interaction controls /} ; } challenge 3: undo/redo with branching history supporting a robust undo/redo system with branching history proved essential for experimentation: typescript // action history management class actionhistory { constructor { this.past = ; this.future = ; this.branches = new map; this.currentbranch = null; } recordactionaction, resultingstate { // truncate future if we're in the middle of history if this.future.length > 0 { // save as potential branch before truncating this.savebranch; this.future = ; } this.past.push{ action, state: deepcloneresultingstate }; } undo { if this.past.length <= 1 return null; // keep initial state const current = this.past.pop; this.future.unshiftcurrent; return this.pastthis.past.length - 1.state; } redo { if this.future.length === 0 return null; const next = this.future.shift; this.past.pushnext; return next.state; } // branch management methods... } user experience considerations technical implementation was only half the battle. creating an intuitive user experience required careful attention to several aspects: progressive disclosure not all users need to see all options at once. we implemented progressive disclosure to reduce cognitive load: 1. basic field properties visible by default 2. advanced options accessible through expandable sections 3. developer-focused features available but not intrusive real-time collaboration multiple team members often work on content models simultaneously. our collaboration features include: - live cursor positions - user presence indicators - action attribution - conflict resolution with smart merging - change history with author information documentation integration we integrated contextual documentation directly into the editor: - field type explanations - best practice suggestions - schema validation warnings - performance impact notes what's coming next the current visual model editor is just the beginning. our roadmap includes: 1. ai-assisted modeling - suggestion of field types based on names - schema generation from natural language descriptions - automatic detection of common patterns - optimization recommendations 2. advanced visualization options - alternative layout algorithms - custom themes and visual styles - expanded relationship visualization - filtered views for complex models 3. enhanced collaboration - comment threads on specific model elements - approval workflows for schema changes - role-based access controls - contextual communication tools lessons learned building scalar's visual model editor taught us valuable lessons about balancing technical precision with usability: 1. start with clear constraints - defining the boundaries of what the editor should do helped focus our efforts 2. invest in real-time capabilities - the instant feedback loop between visual and code representations was worth the implementation complexity 3. test with real-world models - our initial assumptions about typical model complexity were challenged by user testing 4. prioritize developer trust - power users need to see and control the underlying implementation 5. design for evolving schemas - content models change over time, and the editing experience needs to support that evolution conclusion creating an intuitive yet powerful visual content modeling tool required solving complex technical challenges and thoughtful ux design. the result is a flexible editor that bridges the gap between technical and non-technical users, enabling teams to collaborate on content models effectively. we're continuously refining the editor based on user feedback, and we're excited about the roadmap ahead. if you have ideas or suggestions for our visual model editor, we'd love to hear from you!",
      "url": "/writing/how-we-built-scalar"
    },
    {
      "id": "blog-9",
      "title": "Open Source at the core of Scalar",
      "slug": "open-source-at-the-core-of-scalar",
      "description": "Why we chose to open source Scalar, how we think about sustainability, and how you can get involved.",
      "date": "2025-03-12",
      "tags": [
        "Community"
      ],
      "content": "Open Source at the core of Scalar Why we chose to open source Scalar, how we think about sustainability, and how you can get involved. Our Open Source Philosophy From day one, we knew Scalar would be an open source project. This wasn't just a marketing decision or a philosophical stance—it was fundamental to our vision for what a modern content management system should be. We believe that content infrastructure is too important to be locked behind proprietary walls. Organizations need to own the...",
      "searchableText": "open source at the core of scalar why we chose to open source scalar, how we think about sustainability, and how you can get involved. community open source at the core of scalar why we chose to open source scalar, how we think about sustainability, and how you can get involved. our open source philosophy from day one, we knew scalar would be an open source project. this wasn't just a marketing decision or a philosophical stance—it was fundamental to our vision for what a modern content management system should be. we believe that content infrastructure is too important to be locked behind proprietary walls. organizations need to own their content model, understand how their data is structured, and have the freedom to evolve their tech stack without vendor lock-in. this post explains our approach to open source, how we balance community and commercial interests, and how you can contribute to scalar's future. why we chose open source our decision to make scalar open source was driven by several key factors: 1. developer trust developers rightfully hesitate to build on black boxes. open source creates trust through transparency—you can see exactly what you're building on, how it works, and even modify it if needed. 2. community innovation no single company can match the creativity and diverse use cases of a vibrant community. some of scalar's most valuable features came from community contributions addressing real-world problems we hadn't encountered. 3. long-term viability open source provides an \"insurance policy\" for users. even if our company changed direction, the core technology would remain available to the community. this stability is crucial for organizations building mission-critical systems. 4. educational value open source code serves as a living educational resource. many developers have told us they learned about content modeling, typescript, or api design by exploring scalar's codebase. our open source model scalar follows a \"open core\" model, with different components under different licenses: mit licensed components the core scalar engine, including: - content type definition system - schema validation - api generation framework - command line interface - core plugins commercial components some enterprise-focused features remain proprietary: - team collaboration tools - enterprise authentication integrations - enhanced security features - white-label customization this model allows us to balance openness with building a sustainable business that can continue investing in scalar's development. governance structure transparency extends to our governance process as well: rfc process significant changes to scalar begin as request for comments rfc documents, which are: 1. published publicly for community review 2. open for comments for at least two weeks 3. reviewed by core maintainers 4. either accepted, rejected, or sent back for revision this process ensures major decisions benefit from community input while maintaining a clear direction. maintainer team our maintainer team includes both scalar employees and community contributors. maintainers have authority to: - review and merge pull requests - participate in rfc discussions - handle issue triage - guide community discussions we're actively working to increase the diversity of our maintainer team, both in terms of backgrounds and organizations represented. building a sustainable project open source needs sustainable funding to thrive long-term. our approach includes: cloud services scalar cloud provides hosted, managed scalar instances with additional features. revenue from this service directly funds open source development. enterprise support organizations that need guaranteed support, custom features, or compliance assistance can purchase enterprise support packages. development partnerships for organizations with specific needs, we offer development partnerships where we build features they need, which then become available to the broader community. transparent allocation we commit to reinvesting at least 30% of our revenue into open source development, community resources, and documentation. community contributions we've been humbled by the quality and quantity of community contributions to scalar. contributors have: - fixed bugs and improved performance - added support for new database backends - created integrations with other tools - translated documentation - developed educational content we express our gratitude not just with words, but through: - highlighting contributors in our release notes - featuring community projects in our showcase - providing direct mentorship for regular contributors - offering special perks like conference tickets and early feature access how to get involved if you're interested in contributing to scalar, there are many ways to get started: for developers - browse our good first issueshttps://github.com/scalar/scalar/issues?q=is%3aissue+is%3aopen+label%3a%22good+first+issue%22 on github - join the dev channel in our discord - try building a plugin using our extension api - help improve test coverage for content experts - contribute to documentation - create tutorials and blog posts - answer questions in the community forum - provide feedback on ux and workflows for organizations - share case studies of how you're using scalar - sponsor development of specific features - contribute developer time to the project - provide infrastructure or services success stories several key contributions show the power of our community: mongodb integration a community member built first-class mongodb support, which is now one of our most popular database options. graphql subscriptions real-time graphql subscriptions began as a community plugin before becoming a core feature. localization framework our entire localization system was designed and implemented by a community contributor who needed multilingual content support. the road ahead our open source vision continues to evolve. upcoming initiatives include: - establishing a more formal governance structure - creating a contributor development program - launching a grant program for ecosystem projects - expanding our documentation in multiple languages conclusion open source isn't just a licensing decision—it's about building technology that respects users' freedom and leverages collective intelligence. we're grateful for every contribution, whether it's code, documentation, bug reports, or simply spreading the word about scalar. if you're using scalar, consider getting involved in the community. and if you're considering contributing, we're here to help you get started. together, we're building not just a content management system, but an ecosystem that makes structured content more accessible to everyone.",
      "url": "/writing/open-source-at-the-core-of-scalar"
    }
  ],
  "documents": [
    {
      "id": "ci-cd-pipeline",
      "title": "CI/CD Pipeline Setup",
      "slug": "ci-cd-pipeline-setup",
      "description": "Complete guide to setting up continuous integration and deployment pipelines with GitHub Actions and AWS.",
      "category": "Development",
      "type": "Guide",
      "searchableText": "ci/cd pipeline setup complete guide to setting up continuous integration and deployment pipelines with github actions and aws. development guide",
      "url": "/library#ci-cd-pipeline-setup"
    },
    {
      "id": "content-marketing",
      "title": "Content Marketing Framework",
      "slug": "content-marketing-framework",
      "description": "Strategic approach to content creation, distribution, and measurement for B2B SaaS companies.",
      "category": "Marketing",
      "type": "Framework",
      "searchableText": "content marketing framework strategic approach to content creation, distribution, and measurement for b2b saas companies. marketing framework",
      "url": "/library#content-marketing-framework"
    },
    {
      "id": "system-design",
      "title": "System Design Patterns",
      "slug": "system-design-patterns",
      "description": "Common architectural patterns for building scalable distributed systems.",
      "category": "Development",
      "type": "Reference",
      "searchableText": "system design patterns common architectural patterns for building scalable distributed systems. development reference",
      "url": "/library#system-design-patterns"
    },
    {
      "id": "api-docs",
      "title": "API Documentation Standards",
      "slug": "api-documentation-standards",
      "description": "Best practices and templates for creating clear, comprehensive API documentation.",
      "category": "Resources",
      "type": "Template",
      "searchableText": "api documentation standards best practices and templates for creating clear, comprehensive api documentation. resources template",
      "url": "/library#api-documentation-standards"
    }
  ],
  "projects": [
    {
      "id": "personal-website",
      "title": "Personal Website",
      "slug": "personal-website",
      "description": "Modern portfolio and blog built with Astro, React, and Tailwind CSS. Features a custom CMS integration, dark mode support, and optimized performance.",
      "technologies": [
        "Astro",
        "TypeScript",
        "Tailwind"
      ],
      "status": "Active",
      "searchableText": "personal website modern portfolio and blog built with astro, react, and tailwind css. features a custom cms integration, dark mode support, and optimized performance. astro typescript tailwind active",
      "url": "/projects#personal-website"
    },
    {
      "id": "cli-tool",
      "title": "CLI Tool",
      "slug": "cli-tool",
      "description": "Command-line tool for developer productivity. Automates common development tasks and provides a unified interface for various tools.",
      "technologies": [
        "Go",
        "Cobra",
        "Docker"
      ],
      "status": "Active",
      "searchableText": "cli tool command-line tool for developer productivity. automates common development tasks and provides a unified interface for various tools. go cobra docker active",
      "url": "/projects#cli-tool"
    },
    {
      "id": "api-library",
      "title": "API Library",
      "slug": "api-library",
      "description": "TypeScript library for REST API integrations. Provides type-safe client generation and automatic retry logic.",
      "technologies": [
        "TypeScript",
        "Node.js",
        "Jest"
      ],
      "status": "Maintained",
      "searchableText": "api library typescript library for rest api integrations. provides type-safe client generation and automatic retry logic. typescript node.js jest maintained",
      "url": "/projects#api-library"
    }
  ],
  "meta": {
    "created": "2025-08-31T03:52:18.678Z",
    "version": "1.0.0"
  }
}